{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useContractKitMethods = void 0;\n\nvar react_1 = require(\"react\");\n\nvar connectors_1 = require(\"./connectors\");\n\nvar constants_1 = require(\"./constants\");\n\nfunction useContractKitMethods(_a, dispatch) {\n  var _this = this;\n\n  var connector = _a.connector,\n      networks = _a.networks,\n      network = _a.network;\n  var destroy = (0, react_1.useCallback)(function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , connector.close()];\n\n          case 1:\n            _a.sent();\n\n            dispatch('destroy');\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, [dispatch, connector]);\n  var initConnector = (0, react_1.useCallback)(function (nextConnector) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var initialisedConnector_1, netId_1, newNetwork, e_1, error;\n\n      var _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _c.trys.push([0, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , nextConnector.initialise()];\n\n          case 1:\n            initialisedConnector_1 = _c.sent();\n            dispatch('initialisedConnector', initialisedConnector_1);\n            return [4\n            /*yield*/\n            , initialisedConnector_1.kit.web3.eth.net.getId()];\n\n          case 2:\n            netId_1 = _c.sent();\n            newNetwork = networks.find(function (n) {\n              return netId_1 === n.chainId;\n            });\n\n            if (newNetwork !== network) {\n              dispatch('setNetwork', network);\n            } // This happens if the network changes on the wallet side\n            // and we need to update what network we're storing\n            // accordingly.\n\n\n            (_a = initialisedConnector_1.onNetworkChange) === null || _a === void 0 ? void 0 : _a.call(initialisedConnector_1, function (chainId) {\n              var network = networks.find(function (n) {\n                return n.chainId === chainId;\n              });\n              if (netId_1 === chainId || !network) return; // TODO: We should probably throw an error if we can't find the new chainId\n\n              if (network) {\n                dispatch('setNetwork', network);\n                initialisedConnector_1.updateKitWithNetwork && initialisedConnector_1.updateKitWithNetwork(network).then(function () {\n                  dispatch('initialisedConnector', initialisedConnector_1);\n                }).catch(function (e) {\n                  console.error('[use-contractkit] Error switching network', nextConnector.type, e);\n                  var error = e instanceof Error ? e : new Error(\"Failed to initialise connector with \".concat(network.name));\n                  dispatch('setConnectorInitError', error);\n                  throw e;\n                });\n              }\n            });\n            (_b = initialisedConnector_1.onAddressChange) === null || _b === void 0 ? void 0 : _b.call(initialisedConnector_1, function (address) {\n              dispatch('setAddress', address);\n            });\n            return [2\n            /*return*/\n            , initialisedConnector_1];\n\n          case 3:\n            e_1 = _c.sent();\n            console.error('[use-contractkit] Error initializing connector', nextConnector.type, e_1);\n            error = e_1 instanceof Error ? e_1 : new Error('Failed to initialise connector');\n            dispatch('setConnectorInitError', error);\n            throw e_1;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, [dispatch, network, networks]); // This is just to be used to for users to explicitly change\n  // the network. It doesn't work for all wallets.\n\n  var updateNetwork = (0, react_1.useCallback)(function (newNetwork) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var connectorArgs, ConnectorConstructor, newConnector;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (constants_1.STATIC_NETWORK_WALLETS.includes(connector.type)) {\n              throw new Error(\"The connected wallet's network must be changed from the wallet.\");\n            }\n\n            if (network === newNetwork) return [2\n            /*return*/\n            ];\n            if (!connector.initialised) return [3\n            /*break*/\n            , 3];\n            connectorArgs = JSON.parse(localStorage.getItem(constants_1.localStorageKeys.lastUsedWalletArguments) || '[]');\n            return [4\n            /*yield*/\n            , connector.close()];\n\n          case 1:\n            _a.sent();\n\n            ConnectorConstructor = connectors_1.CONNECTOR_TYPES[connector.type];\n            newConnector = new (ConnectorConstructor.bind.apply(ConnectorConstructor, __spreadArray([void 0, newNetwork], __read(connectorArgs), false)))();\n            return [4\n            /*yield*/\n            , initConnector(newConnector)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            dispatch('setNetwork', newNetwork);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, [dispatch, connector, network, initConnector]);\n  var connect = (0, react_1.useCallback)(function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var connectionResultPromise, newConnector;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            connectionResultPromise = new Promise(function (resolve) {\n              dispatch('setConnectionCallback', resolve);\n            });\n            return [4\n            /*yield*/\n            , connectionResultPromise];\n\n          case 1:\n            newConnector = _a.sent();\n            dispatch('setConnectionCallback', null);\n\n            if (newConnector === false) {\n              throw new Error('Connection cancelled');\n            }\n\n            return [2\n            /*return*/\n            , newConnector];\n        }\n      });\n    });\n  }, [dispatch]);\n  var getConnectedKit = (0, react_1.useCallback)(function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var initialisedConnection;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            initialisedConnection = connector;\n            if (!(connector.type === constants_1.WalletTypes.Unauthenticated)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , connect()];\n\n          case 1:\n            initialisedConnection = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            if (!!initialisedConnection.initialised) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , initConnector(initialisedConnection)];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            , initialisedConnection.kit];\n        }\n      });\n    });\n  }, [connect, connector, initConnector]);\n  var updateFeeCurrency = (0, react_1.useCallback)(function (newFeeCurrency) {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , connector.updateFeeCurrency(newFeeCurrency)];\n\n          case 1:\n            _a.sent();\n\n            dispatch('setFeeCurrency', newFeeCurrency);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, [connector, dispatch]);\n  var performActions = (0, react_1.useCallback)(function () {\n    var operations = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      operations[_i] = arguments[_i];\n    }\n\n    return __awaiter(_this, void 0, void 0, function () {\n      var kit, results, operations_1, operations_1_1, op, _a, _b, e_2, e_3_1;\n\n      var e_3, _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , getConnectedKit()];\n\n          case 1:\n            kit = _d.sent();\n            dispatch('setPendingActionCount', operations.length);\n            results = [];\n            _d.label = 2;\n\n          case 2:\n            _d.trys.push([2, 10, 11, 12]);\n\n            operations_1 = __values(operations), operations_1_1 = operations_1.next();\n            _d.label = 3;\n\n          case 3:\n            if (!!operations_1_1.done) return [3\n            /*break*/\n            , 9];\n            op = operations_1_1.value;\n            _d.label = 4;\n\n          case 4:\n            _d.trys.push([4, 6,, 7]);\n\n            _b = (_a = results).push;\n            return [4\n            /*yield*/\n            , op(kit)];\n\n          case 5:\n            _b.apply(_a, [_d.sent()]);\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            e_2 = _d.sent();\n            dispatch('setPendingActionCount', 0);\n            throw e_2;\n\n          case 7:\n            dispatch('decrementPendingActionCount');\n            _d.label = 8;\n\n          case 8:\n            operations_1_1 = operations_1.next();\n            return [3\n            /*break*/\n            , 3];\n\n          case 9:\n            return [3\n            /*break*/\n            , 12];\n\n          case 10:\n            e_3_1 = _d.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3\n            /*break*/\n            , 12];\n\n          case 11:\n            try {\n              if (operations_1_1 && !operations_1_1.done && (_c = operations_1.return)) _c.call(operations_1);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 12:\n            return [2\n            /*return*/\n            , results];\n        }\n      });\n    });\n  }, [getConnectedKit, dispatch]);\n  return {\n    destroy: destroy,\n    initConnector: initConnector,\n    updateNetwork: updateNetwork,\n    connect: connect,\n    getConnectedKit: getConnectedKit,\n    performActions: performActions,\n    updateFeeCurrency: updateFeeCurrency\n  };\n}\n\nexports.useContractKitMethods = useContractKitMethods;","map":{"version":3,"sources":["../src/use-contract-kit-methods.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useContractKitMethods = void 0;\nvar react_1 = require(\"react\");\nvar connectors_1 = require(\"./connectors\");\nvar constants_1 = require(\"./constants\");\nfunction useContractKitMethods(_a, dispatch) {\n    var _this = this;\n    var connector = _a.connector, networks = _a.networks, network = _a.network;\n    var destroy = (0, react_1.useCallback)(function () { return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, connector.close()];\n                case 1:\n                    _a.sent();\n                    dispatch('destroy');\n                    return [2 /*return*/];\n            }\n        });\n    }); }, [dispatch, connector]);\n    var initConnector = (0, react_1.useCallback)(function (nextConnector) { return __awaiter(_this, void 0, void 0, function () {\n        var initialisedConnector_1, netId_1, newNetwork, e_1, error;\n        var _a, _b;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    _c.trys.push([0, 3, , 4]);\n                    return [4 /*yield*/, nextConnector.initialise()];\n                case 1:\n                    initialisedConnector_1 = _c.sent();\n                    dispatch('initialisedConnector', initialisedConnector_1);\n                    return [4 /*yield*/, initialisedConnector_1.kit.web3.eth.net.getId()];\n                case 2:\n                    netId_1 = _c.sent();\n                    newNetwork = networks.find(function (n) { return netId_1 === n.chainId; });\n                    if (newNetwork !== network) {\n                        dispatch('setNetwork', network);\n                    }\n                    // This happens if the network changes on the wallet side\n                    // and we need to update what network we're storing\n                    // accordingly.\n                    (_a = initialisedConnector_1.onNetworkChange) === null || _a === void 0 ? void 0 : _a.call(initialisedConnector_1, function (chainId) {\n                        var network = networks.find(function (n) { return n.chainId === chainId; });\n                        if (netId_1 === chainId || !network)\n                            return;\n                        // TODO: We should probably throw an error if we can't find the new chainId\n                        if (network) {\n                            dispatch('setNetwork', network);\n                            initialisedConnector_1.updateKitWithNetwork &&\n                                initialisedConnector_1\n                                    .updateKitWithNetwork(network)\n                                    .then(function () {\n                                    dispatch('initialisedConnector', initialisedConnector_1);\n                                })\n                                    .catch(function (e) {\n                                    console.error('[use-contractkit] Error switching network', nextConnector.type, e);\n                                    var error = e instanceof Error\n                                        ? e\n                                        : new Error(\"Failed to initialise connector with \".concat(network.name));\n                                    dispatch('setConnectorInitError', error);\n                                    throw e;\n                                });\n                        }\n                    });\n                    (_b = initialisedConnector_1.onAddressChange) === null || _b === void 0 ? void 0 : _b.call(initialisedConnector_1, function (address) {\n                        dispatch('setAddress', address);\n                    });\n                    return [2 /*return*/, initialisedConnector_1];\n                case 3:\n                    e_1 = _c.sent();\n                    console.error('[use-contractkit] Error initializing connector', nextConnector.type, e_1);\n                    error = e_1 instanceof Error ? e_1 : new Error('Failed to initialise connector');\n                    dispatch('setConnectorInitError', error);\n                    throw e_1;\n                case 4: return [2 /*return*/];\n            }\n        });\n    }); }, [dispatch, network, networks]);\n    // This is just to be used to for users to explicitly change\n    // the network. It doesn't work for all wallets.\n    var updateNetwork = (0, react_1.useCallback)(function (newNetwork) { return __awaiter(_this, void 0, void 0, function () {\n        var connectorArgs, ConnectorConstructor, newConnector;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (constants_1.STATIC_NETWORK_WALLETS.includes(connector.type)) {\n                        throw new Error(\"The connected wallet's network must be changed from the wallet.\");\n                    }\n                    if (network === newNetwork)\n                        return [2 /*return*/];\n                    if (!connector.initialised) return [3 /*break*/, 3];\n                    connectorArgs = JSON.parse(localStorage.getItem(constants_1.localStorageKeys.lastUsedWalletArguments) || '[]');\n                    return [4 /*yield*/, connector.close()];\n                case 1:\n                    _a.sent();\n                    ConnectorConstructor = connectors_1.CONNECTOR_TYPES[connector.type];\n                    newConnector = new (ConnectorConstructor.bind.apply(ConnectorConstructor, __spreadArray([void 0, newNetwork], __read(connectorArgs), false)))();\n                    return [4 /*yield*/, initConnector(newConnector)];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3:\n                    dispatch('setNetwork', newNetwork);\n                    return [2 /*return*/];\n            }\n        });\n    }); }, [dispatch, connector, network, initConnector]);\n    var connect = (0, react_1.useCallback)(function () { return __awaiter(_this, void 0, void 0, function () {\n        var connectionResultPromise, newConnector;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    connectionResultPromise = new Promise(function (resolve) {\n                        dispatch('setConnectionCallback', resolve);\n                    });\n                    return [4 /*yield*/, connectionResultPromise];\n                case 1:\n                    newConnector = _a.sent();\n                    dispatch('setConnectionCallback', null);\n                    if (newConnector === false) {\n                        throw new Error('Connection cancelled');\n                    }\n                    return [2 /*return*/, newConnector];\n            }\n        });\n    }); }, [dispatch]);\n    var getConnectedKit = (0, react_1.useCallback)(function () { return __awaiter(_this, void 0, void 0, function () {\n        var initialisedConnection;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    initialisedConnection = connector;\n                    if (!(connector.type === constants_1.WalletTypes.Unauthenticated)) return [3 /*break*/, 2];\n                    return [4 /*yield*/, connect()];\n                case 1:\n                    initialisedConnection = _a.sent();\n                    return [3 /*break*/, 4];\n                case 2:\n                    if (!!initialisedConnection.initialised) return [3 /*break*/, 4];\n                    return [4 /*yield*/, initConnector(initialisedConnection)];\n                case 3:\n                    _a.sent();\n                    _a.label = 4;\n                case 4: return [2 /*return*/, initialisedConnection.kit];\n            }\n        });\n    }); }, [connect, connector, initConnector]);\n    var updateFeeCurrency = (0, react_1.useCallback)(function (newFeeCurrency) { return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, connector.updateFeeCurrency(newFeeCurrency)];\n                case 1:\n                    _a.sent();\n                    dispatch('setFeeCurrency', newFeeCurrency);\n                    return [2 /*return*/];\n            }\n        });\n    }); }, [connector, dispatch]);\n    var performActions = (0, react_1.useCallback)(function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i] = arguments[_i];\n        }\n        return __awaiter(_this, void 0, void 0, function () {\n            var kit, results, operations_1, operations_1_1, op, _a, _b, e_2, e_3_1;\n            var e_3, _c;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0: return [4 /*yield*/, getConnectedKit()];\n                    case 1:\n                        kit = _d.sent();\n                        dispatch('setPendingActionCount', operations.length);\n                        results = [];\n                        _d.label = 2;\n                    case 2:\n                        _d.trys.push([2, 10, 11, 12]);\n                        operations_1 = __values(operations), operations_1_1 = operations_1.next();\n                        _d.label = 3;\n                    case 3:\n                        if (!!operations_1_1.done) return [3 /*break*/, 9];\n                        op = operations_1_1.value;\n                        _d.label = 4;\n                    case 4:\n                        _d.trys.push([4, 6, , 7]);\n                        _b = (_a = results).push;\n                        return [4 /*yield*/, op(kit)];\n                    case 5:\n                        _b.apply(_a, [_d.sent()]);\n                        return [3 /*break*/, 7];\n                    case 6:\n                        e_2 = _d.sent();\n                        dispatch('setPendingActionCount', 0);\n                        throw e_2;\n                    case 7:\n                        dispatch('decrementPendingActionCount');\n                        _d.label = 8;\n                    case 8:\n                        operations_1_1 = operations_1.next();\n                        return [3 /*break*/, 3];\n                    case 9: return [3 /*break*/, 12];\n                    case 10:\n                        e_3_1 = _d.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 12];\n                    case 11:\n                        try {\n                            if (operations_1_1 && !operations_1_1.done && (_c = operations_1.return)) _c.call(operations_1);\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                        return [7 /*endfinally*/];\n                    case 12: return [2 /*return*/, results];\n                }\n            });\n        });\n    }, [getConnectedKit, dispatch]);\n    return {\n        destroy: destroy,\n        initConnector: initConnector,\n        updateNetwork: updateNetwork,\n        connect: connect,\n        getConnectedKit: getConnectedKit,\n        performActions: performActions,\n        updateFeeCurrency: updateFeeCurrency,\n    };\n}\nexports.useContractKitMethods = useContractKitMethods;\n//# sourceMappingURL=use-contract-kit-methods.js.map"]},"metadata":{},"sourceType":"script"}