{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Lock = void 0;\n\nvar events_1 = require(\"events\");\n\nvar LockEvent;\n\n(function (LockEvent) {\n  LockEvent[\"Unlock\"] = \"unlock\";\n})(LockEvent || (LockEvent = {})); // Lock which can be used to ensure mutual exclusion in concurrent code.\n//\n// This lock is non-reentrant, and attempting to acquire it while holding the lock will result in a deadlock.\n\n\nvar Lock =\n/** @class */\nfunction () {\n  function Lock() {\n    this.locked = false;\n    this.emitter = new events_1.EventEmitter();\n  } // Attempt to acquire the lock without blocking.\n  // @returns {boolean} True if the lock was acquired.\n\n\n  Lock.prototype.tryAcquire = function () {\n    if (!this.locked) {\n      this.locked = true;\n      return true;\n    }\n\n    return false;\n  }; // Acquire the lock, blocking until the lock is available.\n\n\n  Lock.prototype.acquire = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      // Attempt to grab the lock without waiting.\n      if (_this.tryAcquire()) {\n        resolve();\n        return;\n      } // Wait for an event emitted when releasing the lock.\n\n\n      var callback = function () {\n        try {\n          if (_this.tryAcquire()) {\n            _this.emitter.removeListener(LockEvent.Unlock, callback);\n\n            resolve();\n          }\n        } catch (error) {\n          reject(error);\n        }\n      };\n\n      _this.emitter.on(LockEvent.Unlock, callback);\n    });\n  }; // Release the lock such that another caller can acquire it.\n  // If not locked, calling this method has no effect.\n\n\n  Lock.prototype.release = function () {\n    if (this.locked) {\n      this.locked = false;\n      this.emitter.emit(LockEvent.Unlock);\n    }\n  };\n\n  return Lock;\n}();\n\nexports.Lock = Lock;","map":{"version":3,"sources":["../src/lock.ts"],"names":[],"mappings":";;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,IAAK,SAAL;;AAAA,CAAA,UAAK,SAAL,EAAc;AACZ,EAAA,SAAA,CAAA,QAAA,CAAA,GAAA,QAAA;AACD,CAFD,EAAK,SAAS,KAAT,SAAS,GAAA,EAAA,CAAd,E,CAIA;AACA;AACA;;;AACA,IAAA,IAAA;AAAA;AAAA,YAAA;AAIE,WAAA,IAAA,GAAA;AAHQ,SAAA,MAAA,GAAkB,KAAlB;AAIN,SAAK,OAAL,GAAe,IAAI,QAAA,CAAA,YAAJ,EAAf;AACD,GANH,CAQE;AACA;;;AACA,EAAA,IAAA,CAAA,SAAA,CAAA,UAAA,GAAA,YAAA;AACE,QAAI,CAAC,KAAK,MAAV,EAAkB;AAChB,WAAK,MAAL,GAAc,IAAd;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD,GAND,CAVF,CAkBE;;;AACA,EAAA,IAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,WAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AACjC;AACA,UAAI,KAAI,CAAC,UAAL,EAAJ,EAAuB;AACrB,QAAA,OAAO;AACP;AACD,OALgC,CAOjC;;;AACA,UAAM,QAAQ,GAAG,YAAA;AACf,YAAI;AACF,cAAI,KAAI,CAAC,UAAL,EAAJ,EAAuB;AACrB,YAAA,KAAI,CAAC,OAAL,CAAa,cAAb,CAA4B,SAAS,CAAC,MAAtC,EAA8C,QAA9C;;AACA,YAAA,OAAO;AACR;AACF,SALD,CAKE,OAAO,KAAP,EAAc;AACd,UAAA,MAAM,CAAC,KAAD,CAAN;AACD;AACF,OATD;;AAUA,MAAA,KAAI,CAAC,OAAL,CAAa,EAAb,CAAgB,SAAS,CAAC,MAA1B,EAAkC,QAAlC;AACD,KAnBM,CAAP;AAoBD,GArBD,CAnBF,CA0CE;AACA;;;AACA,EAAA,IAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACE,QAAI,KAAK,MAAT,EAAiB;AACf,WAAK,MAAL,GAAc,KAAd;AACA,WAAK,OAAL,CAAa,IAAb,CAAkB,SAAS,CAAC,MAA5B;AACD;AACF,GALD;;AAMF,SAAA,IAAA;AAAC,CAlDD,EAAA;;AAAa,OAAA,CAAA,IAAA,GAAA,IAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lock = void 0;\nvar events_1 = require(\"events\");\nvar LockEvent;\n(function (LockEvent) {\n    LockEvent[\"Unlock\"] = \"unlock\";\n})(LockEvent || (LockEvent = {}));\n// Lock which can be used to ensure mutual exclusion in concurrent code.\n//\n// This lock is non-reentrant, and attempting to acquire it while holding the lock will result in a deadlock.\nvar Lock = /** @class */ (function () {\n    function Lock() {\n        this.locked = false;\n        this.emitter = new events_1.EventEmitter();\n    }\n    // Attempt to acquire the lock without blocking.\n    // @returns {boolean} True if the lock was acquired.\n    Lock.prototype.tryAcquire = function () {\n        if (!this.locked) {\n            this.locked = true;\n            return true;\n        }\n        return false;\n    };\n    // Acquire the lock, blocking until the lock is available.\n    Lock.prototype.acquire = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // Attempt to grab the lock without waiting.\n            if (_this.tryAcquire()) {\n                resolve();\n                return;\n            }\n            // Wait for an event emitted when releasing the lock.\n            var callback = function () {\n                try {\n                    if (_this.tryAcquire()) {\n                        _this.emitter.removeListener(LockEvent.Unlock, callback);\n                        resolve();\n                    }\n                }\n                catch (error) {\n                    reject(error);\n                }\n            };\n            _this.emitter.on(LockEvent.Unlock, callback);\n        });\n    };\n    // Release the lock such that another caller can acquire it.\n    // If not locked, calling this method has no effect.\n    Lock.prototype.release = function () {\n        if (this.locked) {\n            this.locked = false;\n            this.emitter.emit(LockEvent.Unlock);\n        }\n    };\n    return Lock;\n}());\nexports.Lock = Lock;\n//# sourceMappingURL=lock.js.map"]},"metadata":{},"sourceType":"script"}