{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AttestationServiceStatusState = exports.AttestationsWrapper = exports.AttestationState = exports.getSecurityCodePrefix = void 0;\n\nvar address_1 = require(\"@celo/base/lib/address\");\n\nvar async_1 = require(\"@celo/base/lib/async\");\n\nvar collections_1 = require(\"@celo/base/lib/collections\");\n\nvar parsing_1 = require(\"@celo/base/lib/parsing\");\n\nvar string_1 = require(\"@celo/base/lib/string\");\n\nvar connect_1 = require(\"@celo/connect\");\n\nvar lib_1 = require(\"@celo/utils/lib\");\n\nvar typed_data_constructors_1 = require(\"@celo/utils/lib/typed-data-constructors\");\n\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n\nvar cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\n\nvar base_1 = require(\"../base\");\n\nvar identity_1 = require(\"../identity\");\n\nvar BaseWrapper_1 = require(\"./BaseWrapper\");\n\nfunction hashAddressToSingleDigit(address) {\n  return new bignumber_js_1.default(address.toLowerCase()).modulo(10).toNumber();\n}\n\nfunction getSecurityCodePrefix(issuerAddress) {\n  return \"\" + hashAddressToSingleDigit(issuerAddress);\n}\n\nexports.getSecurityCodePrefix = getSecurityCodePrefix;\n/**\n * Contract for managing identities\n */\n\nvar AttestationState;\n\n(function (AttestationState) {\n  AttestationState[AttestationState[\"None\"] = 0] = \"None\";\n  AttestationState[AttestationState[\"Incomplete\"] = 1] = \"Incomplete\";\n  AttestationState[AttestationState[\"Complete\"] = 2] = \"Complete\";\n})(AttestationState = exports.AttestationState || (exports.AttestationState = {}));\n\nfunction parseGetCompletableAttestations(response) {\n  var metadataURLs = (0, parsing_1.parseSolidityStringArray)(response[2].map(BaseWrapper_1.valueToInt), response[3]);\n  return (0, collections_1.zip3)(response[0].map(BaseWrapper_1.valueToInt), response[1], metadataURLs).map(function (_a) {\n    var blockNumber = _a[0],\n        issuer = _a[1],\n        metadataURL = _a[2];\n    return {\n      blockNumber: blockNumber,\n      issuer: issuer,\n      metadataURL: metadataURL\n    };\n  });\n}\n\nvar AttestationsWrapper =\n/** @class */\nfunction (_super) {\n  __extends(AttestationsWrapper, _super);\n\n  function AttestationsWrapper() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     *  Returns the time an attestation can be completable before it is considered expired\n     */\n\n\n    _this.attestationExpiryBlocks = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.attestationExpiryBlocks, undefined, BaseWrapper_1.valueToInt);\n    /**\n     * Returns the attestation request fee in a given currency.\n     * @param address Token address.\n     * @returns The fee as big number.\n     */\n\n    _this.attestationRequestFees = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.attestationRequestFees, undefined, BaseWrapper_1.valueToBigNumber);\n    _this.selectIssuersWaitBlocks = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.selectIssuersWaitBlocks, undefined, BaseWrapper_1.valueToInt);\n    /**\n     * @notice Returns the unselected attestation request for an identifier/account pair, if any.\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param account Address of the account\n     */\n\n    _this.getUnselectedRequest = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getUnselectedRequest, undefined, function (res) {\n      return {\n        blockNumber: (0, BaseWrapper_1.valueToInt)(res[0]),\n        attestationsRequested: (0, BaseWrapper_1.valueToInt)(res[1]),\n        attestationRequestFeeToken: res[2]\n      };\n    });\n    /**\n     * @notice Checks if attestation request is expired.\n     * @param attestationRequestBlockNumber Attestation Request Block Number to be checked\n     */\n\n    _this.isAttestationExpired = function (attestationRequestBlockNumber) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var attestationExpiryBlocks, blockNumber;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.attestationExpiryBlocks()];\n\n            case 1:\n              attestationExpiryBlocks = _a.sent();\n              return [4\n              /*yield*/\n              , this.kit.connection.getBlockNumber()];\n\n            case 2:\n              blockNumber = _a.sent();\n              return [2\n              /*return*/\n              , blockNumber >= attestationRequestBlockNumber + attestationExpiryBlocks];\n          }\n        });\n      });\n    };\n    /**\n     * @notice Waits for appropriate block numbers for before issuer can be selected\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param account Address of the account\n     */\n\n\n    _this.waitForSelectingIssuers = function (identifier, account, timeoutSeconds, pollDurationSeconds) {\n      if (timeoutSeconds === void 0) {\n        timeoutSeconds = 120;\n      }\n\n      if (pollDurationSeconds === void 0) {\n        pollDurationSeconds = 1;\n      }\n\n      return __awaiter(_this, void 0, void 0, function () {\n        var startTime, unselectedRequest, waitBlocks, blockNumber;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              startTime = Date.now();\n              return [4\n              /*yield*/\n              , this.getUnselectedRequest(identifier, account)];\n\n            case 1:\n              unselectedRequest = _a.sent();\n              return [4\n              /*yield*/\n              , this.selectIssuersWaitBlocks()];\n\n            case 2:\n              waitBlocks = _a.sent();\n\n              if (unselectedRequest.blockNumber === 0) {\n                throw new Error('No unselectedRequest to wait for');\n              }\n\n              _a.label = 3;\n\n            case 3:\n              if (!(Date.now() - startTime < timeoutSeconds * 1000)) return [3\n              /*break*/\n              , 6];\n              return [4\n              /*yield*/\n              , this.kit.connection.getBlockNumber()];\n\n            case 4:\n              blockNumber = _a.sent();\n\n              if (blockNumber >= unselectedRequest.blockNumber + waitBlocks) {\n                return [2\n                /*return*/\n                ];\n              }\n\n              return [4\n              /*yield*/\n              , (0, async_1.sleep)(pollDurationSeconds * 1000)];\n\n            case 5:\n              _a.sent();\n\n              return [3\n              /*break*/\n              , 3];\n\n            case 6:\n              throw new Error('Timeout while waiting for selecting issuers');\n          }\n        });\n      });\n    };\n    /**\n     * Returns the issuers of attestations for a phoneNumber/account combo\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param account Address of the account\n     */\n\n\n    _this.getAttestationIssuers = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getAttestationIssuers);\n    /**\n     * Returns the attestation state of a phone number/account/issuer tuple\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param account Address of the account\n     */\n\n    _this.getAttestationState = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getAttestationState, undefined, function (state) {\n      return {\n        attestationState: (0, BaseWrapper_1.valueToInt)(state[0])\n      };\n    });\n    /**\n     * Returns the attestation stats of a identifer/account pair\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param account Address of the account\n     */\n\n    _this.getAttestationStat = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getAttestationStats, undefined, function (stat) {\n      return {\n        completed: (0, BaseWrapper_1.valueToInt)(stat[0]),\n        total: (0, BaseWrapper_1.valueToInt)(stat[1])\n      };\n    });\n\n    _this.makeIsIssuerRunningAttestationService = function (tries) {\n      if (tries === void 0) {\n        tries = 3;\n      }\n\n      return function (arg) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var metadata, attestationServiceURLClaim, nameClaim, resp, _a, status_1, version, error_1;\n\n          return __generator(this, function (_b) {\n            switch (_b.label) {\n              case 0:\n                _b.trys.push([0, 4,, 5]);\n\n                return [4\n                /*yield*/\n                , identity_1.IdentityMetadataWrapper.fetchFromURL(this.kit, arg.metadataURL, tries)];\n\n              case 1:\n                metadata = _b.sent();\n                attestationServiceURLClaim = metadata.findClaim(identity_1.ClaimTypes.ATTESTATION_SERVICE_URL);\n\n                if (attestationServiceURLClaim === undefined) {\n                  throw new Error(\"No attestation service URL registered for \" + arg.issuer);\n                }\n\n                nameClaim = metadata.findClaim(identity_1.ClaimTypes.NAME);\n                return [4\n                /*yield*/\n                , (0, cross_fetch_1.default)(\"\" + attestationServiceURLClaim.url + (attestationServiceURLClaim.url.substr(-1) === '/' ? '' : '/') + \"status\")];\n\n              case 2:\n                resp = _b.sent();\n\n                if (!resp.ok) {\n                  throw new Error(\"Request failed with status \" + resp.status);\n                }\n\n                return [4\n                /*yield*/\n                , resp.json()];\n\n              case 3:\n                _a = _b.sent(), status_1 = _a.status, version = _a.version;\n\n                if (status_1 !== 'ok') {\n                  return [2\n                  /*return*/\n                  , {\n                    isValid: false,\n                    issuer: arg.issuer\n                  }];\n                }\n\n                return [2\n                /*return*/\n                , {\n                  isValid: true,\n                  result: {\n                    blockNumber: arg.blockNumber,\n                    issuer: arg.issuer,\n                    attestationServiceURL: attestationServiceURLClaim.url,\n                    name: nameClaim ? nameClaim.name : undefined,\n                    version: version\n                  }\n                }];\n\n              case 4:\n                error_1 = _b.sent();\n                return [2\n                /*return*/\n                , {\n                  isValid: false,\n                  issuer: arg.issuer\n                }];\n\n              case 5:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      };\n    };\n    /**\n     * Returns the attestation signer for the specified account.\n     * @param account The address of token rewards are accumulated in.\n     * @param account The address of the account.\n     * @return The reward amount.\n     */\n\n\n    _this.getPendingWithdrawals = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.pendingWithdrawals, undefined, BaseWrapper_1.valueToBigNumber);\n    /**\n     * Allows issuers to withdraw accumulated attestation rewards\n     * @param address The address of the token that will be withdrawn\n     */\n\n    _this.withdraw = (0, BaseWrapper_1.proxySend)(_this.kit, _this.contract.methods.withdraw);\n    /**\n     * Returns the list of accounts associated with an identifier.\n     * @param identifier Attestation identifier (e.g. phone hash)\n     */\n\n    _this.lookupAccountsForIdentifier = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.lookupAccountsForIdentifier);\n    /**\n     * Updates sender's approval status on whether to allow an attestation identifier\n     * mapping to be transfered from one address to another.\n     * @param identifier The identifier for this attestation.\n     * @param index The index of the account in the accounts array.\n     * @param from The current attestation address to which the identifier is mapped.\n     * @param to The new address to map to identifier.\n     * @param status The approval status\n     */\n\n    _this.approveTransfer = (0, BaseWrapper_1.proxySend)(_this.kit, _this.contract.methods.approveTransfer);\n    return _this;\n  }\n  /**\n   * Returns the verified status of an identifier/account pair indicating whether the attestation\n   * stats for a given pair are completed beyond a certain threshold of confidence (aka \"verified\")\n   * @param identifier Attestation identifier (e.g. phone hash)\n   * @param account Address of the account\n   * @param numAttestationsRequired Optional number of attestations required.  Will default to\n   *  hardcoded value if absent.\n   * @param attestationThreshold Optional threshold for fraction attestations completed. Will\n   *  default to hardcoded value if absent.\n   */\n\n\n  AttestationsWrapper.prototype.getVerifiedStatus = function (identifier, account, numAttestationsRequired, attestationThreshold) {\n    return __awaiter(this, void 0, void 0, function () {\n      var attestationStats;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getAttestationStat(identifier, account)];\n\n          case 1:\n            attestationStats = _a.sent();\n            return [2\n            /*return*/\n            , lib_1.AttestationUtils.isAccountConsideredVerified(attestationStats, numAttestationsRequired, attestationThreshold)];\n        }\n      });\n    });\n  };\n  /**\n   * Calculates the amount of StableToken required to request Attestations\n   * @param attestationsRequested  The number of attestations to request\n   */\n\n\n  AttestationsWrapper.prototype.getAttestationFeeRequired = function (attestationsRequested) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenAddress, attestationFee;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.kit.registry.addressFor(base_1.CeloContract.StableToken)];\n\n          case 1:\n            tokenAddress = _a.sent();\n            return [4\n            /*yield*/\n            , this.contract.methods.getAttestationRequestFee(tokenAddress).call()];\n\n          case 2:\n            attestationFee = _a.sent();\n            return [2\n            /*return*/\n            , new bignumber_js_1.default(attestationFee).times(attestationsRequested)];\n        }\n      });\n    });\n  };\n  /**\n   * Approves the necessary amount of StableToken to request Attestations\n   * @param attestationsRequested The number of attestations to request\n   */\n\n\n  AttestationsWrapper.prototype.approveAttestationFee = function (attestationsRequested) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenContract, fee;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.kit.contracts.getContract(base_1.CeloContract.StableToken)];\n\n          case 1:\n            tokenContract = _a.sent();\n            return [4\n            /*yield*/\n            , this.getAttestationFeeRequired(attestationsRequested)];\n\n          case 2:\n            fee = _a.sent();\n            return [2\n            /*return*/\n            , tokenContract.approve(this.address, fee.toFixed())];\n        }\n      });\n    });\n  };\n  /**\n   * Returns an array of attestations that can be completed, along with the issuers' attestation\n   * service urls\n   * @param identifier Attestation identifier (e.g. phone hash)\n   * @param account Address of the account\n   */\n\n\n  AttestationsWrapper.prototype.getActionableAttestations = function (identifier, account, tries) {\n    if (tries === void 0) {\n      tries = 3;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var result, results;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.contract.methods.getCompletableAttestations(identifier, account).call()];\n\n          case 1:\n            result = _a.sent();\n            return [4\n            /*yield*/\n            , (0, async_1.concurrentMap)(5, parseGetCompletableAttestations(result), this.makeIsIssuerRunningAttestationService(tries))];\n\n          case 2:\n            results = _a.sent();\n            return [2\n            /*return*/\n            , results.map(function (_) {\n              return _.isValid ? _.result : null;\n            }).filter(collections_1.notEmpty)];\n        }\n      });\n    });\n  };\n  /**\n   * Returns an array of issuer addresses that were found to not run the attestation service\n   * @param identifier Attestation identifier (e.g. phone hash)\n   * @param account Address of the account\n   */\n\n\n  AttestationsWrapper.prototype.getNonCompliantIssuers = function (identifier, account, tries) {\n    if (tries === void 0) {\n      tries = 3;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var result, withAttestationServiceURLs;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.contract.methods.getCompletableAttestations(identifier, account).call()];\n\n          case 1:\n            result = _a.sent();\n            return [4\n            /*yield*/\n            , (0, async_1.concurrentMap)(5, parseGetCompletableAttestations(result), this.makeIsIssuerRunningAttestationService(tries))];\n\n          case 2:\n            withAttestationServiceURLs = _a.sent();\n            return [2\n            /*return*/\n            , withAttestationServiceURLs.map(function (_) {\n              return _.isValid ? null : _.issuer;\n            }).filter(collections_1.notEmpty)];\n        }\n      });\n    });\n  };\n  /**\n   * Completes an attestation with the corresponding code\n   * @param identifier Attestation identifier (e.g. phone hash)\n   * @param account Address of the account\n   * @param issuer The issuer of the attestation\n   * @param code The code received by the validator\n   */\n\n\n  AttestationsWrapper.prototype.complete = function (identifier, account, issuer, code) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accounts, attestationSigner, expectedSourceMessage, _a, r, s, v;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.kit.contracts.getAccounts()];\n\n          case 1:\n            accounts = _b.sent();\n            return [4\n            /*yield*/\n            , accounts.getAttestationSigner(issuer)];\n\n          case 2:\n            attestationSigner = _b.sent();\n            expectedSourceMessage = lib_1.AttestationUtils.getAttestationMessageToSignFromIdentifier(identifier, account);\n            _a = lib_1.SignatureUtils.parseSignature(expectedSourceMessage, code, attestationSigner), r = _a.r, s = _a.s, v = _a.v;\n            return [2\n            /*return*/\n            , (0, connect_1.toTransactionObject)(this.kit.connection, this.contract.methods.complete(identifier, v, r, s))];\n        }\n      });\n    });\n  };\n  /**\n   * Given a list of issuers, finds the matching issuer for a given code\n   * @param identifier Attestation identifier (e.g. phone hash)\n   * @param account Address of the account\n   * @param code The code received by the validator\n   * @param issuers The list of potential issuers\n   */\n\n\n  AttestationsWrapper.prototype.findMatchingIssuer = function (identifier, account, code, issuers) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accounts, expectedSourceMessage, _i, issuers_1, issuer, attestationSigner;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.kit.contracts.getAccounts()];\n\n          case 1:\n            accounts = _a.sent();\n            expectedSourceMessage = lib_1.AttestationUtils.getAttestationMessageToSignFromIdentifier(identifier, account);\n            _i = 0, issuers_1 = issuers;\n            _a.label = 2;\n\n          case 2:\n            if (!(_i < issuers_1.length)) return [3\n            /*break*/\n            , 5];\n            issuer = issuers_1[_i];\n            return [4\n            /*yield*/\n            , accounts.getAttestationSigner(issuer)];\n\n          case 3:\n            attestationSigner = _a.sent();\n\n            try {\n              lib_1.SignatureUtils.parseSignature(expectedSourceMessage, code, attestationSigner);\n              return [2\n              /*return*/\n              , issuer];\n            } catch (error) {\n              return [3\n              /*break*/\n              , 4];\n            }\n\n            _a.label = 4;\n\n          case 4:\n            _i++;\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            return [2\n            /*return*/\n            , null];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the current configuration parameters for the contract.\n   * @param tokens List of tokens used for attestation fees.\n   * @return AttestationsConfig object\n   */\n\n\n  AttestationsWrapper.prototype.getConfig = function (tokens) {\n    return __awaiter(this, void 0, void 0, function () {\n      var feeTokens, _a, _b, _c, fees;\n\n      var _d;\n\n      var _this = this;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            if (!(tokens !== null && tokens !== void 0)) return [3\n            /*break*/\n            , 1];\n            _a = tokens;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            _c = (_b = Object).values;\n            return [4\n            /*yield*/\n            , this.kit.celoTokens.getAddresses()];\n\n          case 2:\n            _a = _c.apply(_b, [_e.sent()]);\n            _e.label = 3;\n\n          case 3:\n            feeTokens = _a;\n            return [4\n            /*yield*/\n            , Promise.all(feeTokens.map(function (token) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var fee;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , this.attestationRequestFees(token)];\n\n                    case 1:\n                      fee = _a.sent();\n                      return [2\n                      /*return*/\n                      , {\n                        fee: fee,\n                        address: token\n                      }];\n                  }\n                });\n              });\n            }))];\n\n          case 4:\n            fees = _e.sent();\n            _d = {};\n            return [4\n            /*yield*/\n            , this.attestationExpiryBlocks()];\n\n          case 5:\n            return [2\n            /*return*/\n            , (_d.attestationExpiryBlocks = _e.sent(), _d.attestationRequestFees = fees, _d)];\n        }\n      });\n    });\n  };\n  /**\n   * @dev Returns human readable configuration of the attestations contract\n   * @return AttestationsConfig object\n   */\n\n\n  AttestationsWrapper.prototype.getHumanReadableConfig = function (tokens) {\n    return __awaiter(this, void 0, void 0, function () {\n      var config;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getConfig(tokens)];\n\n          case 1:\n            config = _a.sent();\n            return [2\n            /*return*/\n            , {\n              attestationRequestFees: config.attestationRequestFees,\n              attestationExpiry: (0, BaseWrapper_1.blocksToDurationString)(config.attestationExpiryBlocks)\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Lookup mapped wallet addresses for a given list of identifiers\n   * @param identifiers Attestation identifiers (e.g. phone hashes)\n   */\n\n\n  AttestationsWrapper.prototype.lookupIdentifiers = function (identifiers) {\n    return __awaiter(this, void 0, void 0, function () {\n      var stats, matches, addresses, completed, total, result, rIndex, pIndex, pHash, numberOfMatches, matchingAddresses, mIndex, matchingAddress;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.contract.methods.batchGetAttestationStats(identifiers).call()];\n\n          case 1:\n            stats = _a.sent();\n            matches = stats[0].map(BaseWrapper_1.valueToInt);\n            addresses = stats[1];\n            completed = stats[2].map(BaseWrapper_1.valueToInt);\n            total = stats[3].map(BaseWrapper_1.valueToInt);\n            result = {};\n            rIndex = 0;\n\n            for (pIndex = 0; pIndex < identifiers.length; pIndex++) {\n              pHash = identifiers[pIndex];\n              numberOfMatches = matches[pIndex];\n\n              if (numberOfMatches === 0) {\n                continue;\n              }\n\n              matchingAddresses = {};\n\n              for (mIndex = 0; mIndex < numberOfMatches; mIndex++) {\n                matchingAddress = addresses[rIndex];\n                matchingAddresses[matchingAddress] = {\n                  completed: completed[rIndex],\n                  total: total[rIndex]\n                };\n                rIndex++;\n              }\n\n              result[pHash] = matchingAddresses;\n            }\n\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n  /**\n   * Requests a new attestation\n   * @param identifier Attestation identifier (e.g. phone hash)\n   * @param attestationsRequested The number of attestations to request\n   */\n\n\n  AttestationsWrapper.prototype.request = function (identifier, attestationsRequested) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenAddress;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.kit.registry.addressFor(base_1.CeloContract.StableToken)];\n\n          case 1:\n            tokenAddress = _a.sent();\n            return [2\n            /*return*/\n            , (0, connect_1.toTransactionObject)(this.kit.connection, this.contract.methods.request(identifier, attestationsRequested, tokenAddress))];\n        }\n      });\n    });\n  };\n  /**\n   * Selects the issuers for previously requested attestations for a phone number\n   * @param identifier Attestation identifier (e.g. phone hash)\n   */\n\n\n  AttestationsWrapper.prototype.selectIssuers = function (identifier) {\n    return (0, connect_1.toTransactionObject)(this.kit.connection, this.contract.methods.selectIssuers(identifier));\n  };\n  /**\n   * Waits appropriate number of blocks, then selects issuers for previously requested phone number attestations\n   * @param identifier Attestation identifier (e.g. phone hash)\n   * @param account Address of the account\n   */\n\n\n  AttestationsWrapper.prototype.selectIssuersAfterWait = function (identifier, account, timeoutSeconds, pollDurationSeconds) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.waitForSelectingIssuers(identifier, account, timeoutSeconds, pollDurationSeconds)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , this.selectIssuers(identifier)];\n        }\n      });\n    });\n  };\n  /**\n   * Reveal phone number to issuer\n   * @param serviceURL: validator's attestation service URL\n   * @param body\n   */\n\n\n  AttestationsWrapper.prototype.revealPhoneNumberToIssuer = function (serviceURL, requestBody) {\n    return (0, cross_fetch_1.default)((0, string_1.appendPath)(serviceURL, 'attestations'), {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(requestBody)\n    });\n  };\n  /**\n   * Returns reveal status from validator's attestation service\n   * @param phoneNumber: attestation's phone number\n   * @param account: attestation's account\n   * @param issuer: validator's address\n   * @param serviceURL: validator's attestation service URL\n   * @param pepper: phone number privacy pepper\n   */\n\n\n  AttestationsWrapper.prototype.getRevealStatus = function (phoneNumber, account, issuer, serviceURL, pepper) {\n    var urlParams = new URLSearchParams({\n      phoneNumber: phoneNumber,\n      salt: pepper !== null && pepper !== void 0 ? pepper : '',\n      issuer: issuer,\n      account: account\n    });\n    return (0, cross_fetch_1.default)((0, string_1.appendPath)(serviceURL, 'get_attestations') + '?' + urlParams, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n  };\n  /**\n   * Returns attestation code for provided security code from validator's attestation service\n   * @param serviceURL: validator's attestation service URL\n   * @param body\n   */\n\n\n  AttestationsWrapper.prototype.getAttestationForSecurityCode = function (serviceURL, requestBody, signer) {\n    return __awaiter(this, void 0, void 0, function () {\n      var urlParams, additionalHeaders, signature, response, ok, status, body, _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            urlParams = new URLSearchParams({\n              phoneNumber: requestBody.phoneNumber,\n              account: requestBody.account,\n              issuer: requestBody.issuer\n            });\n            additionalHeaders = {};\n\n            if (requestBody.salt) {\n              urlParams.set('salt', requestBody.salt);\n            }\n\n            if (!requestBody.securityCode) return [3\n            /*break*/\n            , 2];\n            urlParams.set('securityCode', requestBody.securityCode);\n            return [4\n            /*yield*/\n            , this.kit.signTypedData(signer, (0, typed_data_constructors_1.attestationSecurityCode)(requestBody.securityCode))];\n\n          case 1:\n            signature = _c.sent();\n            additionalHeaders = {\n              Authentication: lib_1.SignatureUtils.serializeSignature(signature)\n            };\n            _c.label = 2;\n\n          case 2:\n            return [4\n            /*yield*/\n            , (0, cross_fetch_1.default)((0, string_1.appendPath)(serviceURL, 'get_attestations') + '?' + urlParams, {\n              method: 'GET',\n              headers: __assign({\n                'Content-Type': 'application/json'\n              }, additionalHeaders)\n            })];\n\n          case 3:\n            response = _c.sent();\n            ok = response.ok, status = response.status;\n            if (!ok) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 4:\n            body = _c.sent();\n\n            if (body.attestationCode) {\n              return [2\n              /*return*/\n              , body.attestationCode];\n            }\n\n            _c.label = 5;\n\n          case 5:\n            _a = Error.bind;\n            _b = \"Error getting security code for \" + requestBody.issuer + \". \" + status + \": \";\n            return [4\n            /*yield*/\n            , response.text()];\n\n          case 6:\n            throw new (_a.apply(Error, [void 0, _b + _c.sent()]))();\n        }\n      });\n    });\n  };\n  /**\n   * Validates a given code by the issuer on-chain\n   * @param identifier Attestation identifier (e.g. phone hash)\n   * @param account The address of the account which requested attestation\n   * @param issuer The address of the issuer of the attestation\n   * @param code The code send by the issuer\n   */\n\n\n  AttestationsWrapper.prototype.validateAttestationCode = function (identifier, account, issuer, code) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accounts, attestationSigner, expectedSourceMessage, _a, r, s, v, result;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.kit.contracts.getAccounts()];\n\n          case 1:\n            accounts = _b.sent();\n            return [4\n            /*yield*/\n            , accounts.getAttestationSigner(issuer)];\n\n          case 2:\n            attestationSigner = _b.sent();\n            expectedSourceMessage = lib_1.AttestationUtils.getAttestationMessageToSignFromIdentifier(identifier, account);\n            _a = lib_1.SignatureUtils.parseSignature(expectedSourceMessage, code, attestationSigner), r = _a.r, s = _a.s, v = _a.v;\n            return [4\n            /*yield*/\n            , this.contract.methods.validateAttestationCode(identifier, account, v, r, s).call()];\n\n          case 3:\n            result = _b.sent();\n            return [2\n            /*return*/\n            , result.toLowerCase() !== address_1.NULL_ADDRESS];\n        }\n      });\n    });\n  };\n  /**\n   * Gets the relevant attestation service status for a validator\n   * @param validator Validator to get the attestation service status for\n   */\n\n\n  AttestationsWrapper.prototype.getAttestationServiceStatus = function (validator) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accounts, hasAttestationSigner, attestationSigner, attestationServiceURL, ret, metadataURL, metadata, attestationServiceURLClaim, error_2, statusResponse, statusResponseBody, healthzResponse, healthzResponseBody, error_3, error_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.kit.contracts.getAccounts()];\n\n          case 1:\n            accounts = _a.sent();\n            return [4\n            /*yield*/\n            , accounts.hasAuthorizedAttestationSigner(validator.address)];\n\n          case 2:\n            hasAttestationSigner = _a.sent();\n            return [4\n            /*yield*/\n            , accounts.getAttestationSigner(validator.address)];\n\n          case 3:\n            attestationSigner = _a.sent();\n            ret = __assign(__assign({}, validator), {\n              hasAttestationSigner: hasAttestationSigner,\n              attestationSigner: attestationSigner,\n              attestationServiceURL: null,\n              okStatus: false,\n              error: null,\n              smsProviders: [],\n              blacklistedRegionCodes: [],\n              rightAccount: false,\n              metadataURL: null,\n              state: AttestationServiceStatusState.NoAttestationSigner,\n              version: null,\n              ageOfLatestBlock: null,\n              smsProvidersRandomized: null,\n              maxDeliveryAttempts: null,\n              maxRerequestMins: null,\n              twilioVerifySidProvided: null\n            });\n\n            if (!hasAttestationSigner) {\n              return [2\n              /*return*/\n              , ret];\n            }\n\n            return [4\n            /*yield*/\n            , accounts.getMetadataURL(validator.address)];\n\n          case 4:\n            metadataURL = _a.sent();\n            ret.metadataURL = metadataURL;\n\n            if (!metadataURL) {\n              ret.state = AttestationServiceStatusState.NoMetadataURL;\n              return [2\n              /*return*/\n              , ret];\n            }\n\n            if (metadataURL.startsWith('http://')) {\n              ret.state = AttestationServiceStatusState.InvalidAttestationServiceURL;\n              return [2\n              /*return*/\n              , ret];\n            }\n\n            _a.label = 5;\n\n          case 5:\n            _a.trys.push([5, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , identity_1.IdentityMetadataWrapper.fetchFromURL(this.kit, metadataURL)];\n\n          case 6:\n            metadata = _a.sent();\n            attestationServiceURLClaim = metadata.findClaim(identity_1.ClaimTypes.ATTESTATION_SERVICE_URL);\n\n            if (!attestationServiceURLClaim) {\n              ret.state = AttestationServiceStatusState.NoAttestationServiceURL;\n              return [2\n              /*return*/\n              , ret];\n            }\n\n            attestationServiceURL = attestationServiceURLClaim.url;\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            error_2 = _a.sent();\n            ret.state = error_2.type === 'system' ? AttestationServiceStatusState.MetadataTimeout : AttestationServiceStatusState.InvalidMetadata;\n            ret.error = error_2;\n            return [2\n            /*return*/\n            , ret];\n\n          case 8:\n            ret.attestationServiceURL = attestationServiceURL;\n            _a.label = 9;\n\n          case 9:\n            _a.trys.push([9, 19,, 20]);\n\n            return [4\n            /*yield*/\n            , (0, cross_fetch_1.default)((0, string_1.appendPath)(attestationServiceURL, 'status'))];\n\n          case 10:\n            statusResponse = _a.sent();\n\n            if (!statusResponse.ok) {\n              ret.state = AttestationServiceStatusState.UnreachableAttestationService;\n              return [2\n              /*return*/\n              , ret];\n            }\n\n            ret.okStatus = true;\n            return [4\n            /*yield*/\n            , statusResponse.json()];\n\n          case 11:\n            statusResponseBody = _a.sent();\n            ret.smsProviders = statusResponseBody.smsProviders;\n            ret.rightAccount = (0, address_1.eqAddress)(validator.address, statusResponseBody.accountAddress);\n            ret.state = ret.rightAccount ? AttestationServiceStatusState.Valid : AttestationServiceStatusState.WrongAccount;\n            ret.ageOfLatestBlock = statusResponseBody.ageOfLatestBlock;\n            ret.smsProvidersRandomized = statusResponseBody.smsProvidersRandomized;\n            ret.maxDeliveryAttempts = statusResponseBody.maxDeliveryAttempts;\n            ret.maxRerequestMins = statusResponseBody.maxRerequestMins;\n            ret.twilioVerifySidProvided = statusResponseBody.twilioVerifySidProvided;\n            if (!statusResponseBody.version) return [3\n            /*break*/\n            , 17];\n            ret.version = statusResponseBody.version;\n            _a.label = 12;\n\n          case 12:\n            _a.trys.push([12, 15,, 16]);\n\n            return [4\n            /*yield*/\n            , (0, cross_fetch_1.default)((0, string_1.appendPath)(attestationServiceURL, 'healthz'))];\n\n          case 13:\n            healthzResponse = _a.sent();\n            return [4\n            /*yield*/\n            , healthzResponse.json()];\n\n          case 14:\n            healthzResponseBody = _a.sent();\n\n            if (!healthzResponse.ok) {\n              ret.state = AttestationServiceStatusState.Unhealthy;\n\n              if (healthzResponseBody.error) {\n                ret.error = healthzResponseBody.error;\n              }\n            }\n\n            return [3\n            /*break*/\n            , 16];\n\n          case 15:\n            error_3 = _a.sent();\n            ret.state = AttestationServiceStatusState.UnreachableHealthz;\n            return [3\n            /*break*/\n            , 16];\n\n          case 16:\n            // Whether or not health check is reachable, also check full node status\n            // (overrides UnreachableHealthz status)\n            if (statusResponseBody.ageOfLatestBlock !== null && statusResponseBody.ageOfLatestBlock > 10 || statusResponseBody.isNodeSyncing === true) {\n              ret.state = AttestationServiceStatusState.Unhealthy;\n            }\n\n            return [3\n            /*break*/\n            , 18];\n\n          case 17:\n            // No version implies 1.0.0\n            ret.version = '1.0.0';\n            _a.label = 18;\n\n          case 18:\n            return [3\n            /*break*/\n            , 20];\n\n          case 19:\n            error_4 = _a.sent();\n            ret.state = AttestationServiceStatusState.UnreachableAttestationService;\n            ret.error = error_4;\n            return [3\n            /*break*/\n            , 20];\n\n          case 20:\n            return [2\n            /*return*/\n            , ret];\n        }\n      });\n    });\n  };\n\n  AttestationsWrapper.prototype.revoke = function (identifer, account) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accounts, idx;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.lookupAccountsForIdentifier(identifer)];\n\n          case 1:\n            accounts = _a.sent();\n            idx = accounts.findIndex(function (acc) {\n              return (0, address_1.eqAddress)(acc, account);\n            });\n\n            if (idx < 0) {\n              throw new Error(\"Account not found in identifier's accounts\");\n            }\n\n            return [2\n            /*return*/\n            , (0, connect_1.toTransactionObject)(this.kit.connection, this.contract.methods.revoke(identifer, idx))];\n        }\n      });\n    });\n  };\n\n  return AttestationsWrapper;\n}(BaseWrapper_1.BaseWrapper);\n\nexports.AttestationsWrapper = AttestationsWrapper;\nvar AttestationServiceStatusState;\n\n(function (AttestationServiceStatusState) {\n  AttestationServiceStatusState[\"NoAttestationSigner\"] = \"NoAttestationSigner\";\n  AttestationServiceStatusState[\"NoMetadataURL\"] = \"NoMetadataURL\";\n  AttestationServiceStatusState[\"InvalidMetadata\"] = \"InvalidMetadata\";\n  AttestationServiceStatusState[\"NoAttestationServiceURL\"] = \"NoAttestationServiceURL\";\n  AttestationServiceStatusState[\"InvalidAttestationServiceURL\"] = \"InvalidAttestationServiceURL\";\n  AttestationServiceStatusState[\"UnreachableAttestationService\"] = \"UnreachableAttestationService\";\n  AttestationServiceStatusState[\"Valid\"] = \"Valid\";\n  AttestationServiceStatusState[\"UnreachableHealthz\"] = \"UnreachableHealthz\";\n  AttestationServiceStatusState[\"Unhealthy\"] = \"Unhealthy\";\n  AttestationServiceStatusState[\"WrongAccount\"] = \"WrongAccount\";\n  AttestationServiceStatusState[\"MetadataTimeout\"] = \"MetadataTimeout\";\n})(AttestationServiceStatusState = exports.AttestationServiceStatusState || (exports.AttestationServiceStatusState = {}));","map":{"version":3,"sources":["../../src/wrappers/Attestations.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AttestationServiceStatusState = exports.AttestationsWrapper = exports.AttestationState = exports.getSecurityCodePrefix = void 0;\nvar address_1 = require(\"@celo/base/lib/address\");\nvar async_1 = require(\"@celo/base/lib/async\");\nvar collections_1 = require(\"@celo/base/lib/collections\");\nvar parsing_1 = require(\"@celo/base/lib/parsing\");\nvar string_1 = require(\"@celo/base/lib/string\");\nvar connect_1 = require(\"@celo/connect\");\nvar lib_1 = require(\"@celo/utils/lib\");\nvar typed_data_constructors_1 = require(\"@celo/utils/lib/typed-data-constructors\");\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\nvar base_1 = require(\"../base\");\nvar identity_1 = require(\"../identity\");\nvar BaseWrapper_1 = require(\"./BaseWrapper\");\nfunction hashAddressToSingleDigit(address) {\n    return new bignumber_js_1.default(address.toLowerCase()).modulo(10).toNumber();\n}\nfunction getSecurityCodePrefix(issuerAddress) {\n    return \"\" + hashAddressToSingleDigit(issuerAddress);\n}\nexports.getSecurityCodePrefix = getSecurityCodePrefix;\n/**\n * Contract for managing identities\n */\nvar AttestationState;\n(function (AttestationState) {\n    AttestationState[AttestationState[\"None\"] = 0] = \"None\";\n    AttestationState[AttestationState[\"Incomplete\"] = 1] = \"Incomplete\";\n    AttestationState[AttestationState[\"Complete\"] = 2] = \"Complete\";\n})(AttestationState = exports.AttestationState || (exports.AttestationState = {}));\nfunction parseGetCompletableAttestations(response) {\n    var metadataURLs = (0, parsing_1.parseSolidityStringArray)(response[2].map(BaseWrapper_1.valueToInt), response[3]);\n    return (0, collections_1.zip3)(response[0].map(BaseWrapper_1.valueToInt), response[1], metadataURLs).map(function (_a) {\n        var blockNumber = _a[0], issuer = _a[1], metadataURL = _a[2];\n        return ({ blockNumber: blockNumber, issuer: issuer, metadataURL: metadataURL });\n    });\n}\nvar AttestationsWrapper = /** @class */ (function (_super) {\n    __extends(AttestationsWrapper, _super);\n    function AttestationsWrapper() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         *  Returns the time an attestation can be completable before it is considered expired\n         */\n        _this.attestationExpiryBlocks = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.attestationExpiryBlocks, undefined, BaseWrapper_1.valueToInt);\n        /**\n         * Returns the attestation request fee in a given currency.\n         * @param address Token address.\n         * @returns The fee as big number.\n         */\n        _this.attestationRequestFees = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.attestationRequestFees, undefined, BaseWrapper_1.valueToBigNumber);\n        _this.selectIssuersWaitBlocks = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.selectIssuersWaitBlocks, undefined, BaseWrapper_1.valueToInt);\n        /**\n         * @notice Returns the unselected attestation request for an identifier/account pair, if any.\n         * @param identifier Attestation identifier (e.g. phone hash)\n         * @param account Address of the account\n         */\n        _this.getUnselectedRequest = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getUnselectedRequest, undefined, function (res) { return ({\n            blockNumber: (0, BaseWrapper_1.valueToInt)(res[0]),\n            attestationsRequested: (0, BaseWrapper_1.valueToInt)(res[1]),\n            attestationRequestFeeToken: res[2],\n        }); });\n        /**\n         * @notice Checks if attestation request is expired.\n         * @param attestationRequestBlockNumber Attestation Request Block Number to be checked\n         */\n        _this.isAttestationExpired = function (attestationRequestBlockNumber) { return __awaiter(_this, void 0, void 0, function () {\n            var attestationExpiryBlocks, blockNumber;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.attestationExpiryBlocks()];\n                    case 1:\n                        attestationExpiryBlocks = _a.sent();\n                        return [4 /*yield*/, this.kit.connection.getBlockNumber()];\n                    case 2:\n                        blockNumber = _a.sent();\n                        return [2 /*return*/, blockNumber >= attestationRequestBlockNumber + attestationExpiryBlocks];\n                }\n            });\n        }); };\n        /**\n         * @notice Waits for appropriate block numbers for before issuer can be selected\n         * @param identifier Attestation identifier (e.g. phone hash)\n         * @param account Address of the account\n         */\n        _this.waitForSelectingIssuers = function (identifier, account, timeoutSeconds, pollDurationSeconds) {\n            if (timeoutSeconds === void 0) { timeoutSeconds = 120; }\n            if (pollDurationSeconds === void 0) { pollDurationSeconds = 1; }\n            return __awaiter(_this, void 0, void 0, function () {\n                var startTime, unselectedRequest, waitBlocks, blockNumber;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            startTime = Date.now();\n                            return [4 /*yield*/, this.getUnselectedRequest(identifier, account)];\n                        case 1:\n                            unselectedRequest = _a.sent();\n                            return [4 /*yield*/, this.selectIssuersWaitBlocks()];\n                        case 2:\n                            waitBlocks = _a.sent();\n                            if (unselectedRequest.blockNumber === 0) {\n                                throw new Error('No unselectedRequest to wait for');\n                            }\n                            _a.label = 3;\n                        case 3:\n                            if (!(Date.now() - startTime < timeoutSeconds * 1000)) return [3 /*break*/, 6];\n                            return [4 /*yield*/, this.kit.connection.getBlockNumber()];\n                        case 4:\n                            blockNumber = _a.sent();\n                            if (blockNumber >= unselectedRequest.blockNumber + waitBlocks) {\n                                return [2 /*return*/];\n                            }\n                            return [4 /*yield*/, (0, async_1.sleep)(pollDurationSeconds * 1000)];\n                        case 5:\n                            _a.sent();\n                            return [3 /*break*/, 3];\n                        case 6: throw new Error('Timeout while waiting for selecting issuers');\n                    }\n                });\n            });\n        };\n        /**\n         * Returns the issuers of attestations for a phoneNumber/account combo\n         * @param identifier Attestation identifier (e.g. phone hash)\n         * @param account Address of the account\n         */\n        _this.getAttestationIssuers = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getAttestationIssuers);\n        /**\n         * Returns the attestation state of a phone number/account/issuer tuple\n         * @param identifier Attestation identifier (e.g. phone hash)\n         * @param account Address of the account\n         */\n        _this.getAttestationState = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getAttestationState, undefined, function (state) { return ({ attestationState: (0, BaseWrapper_1.valueToInt)(state[0]) }); });\n        /**\n         * Returns the attestation stats of a identifer/account pair\n         * @param identifier Attestation identifier (e.g. phone hash)\n         * @param account Address of the account\n         */\n        _this.getAttestationStat = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getAttestationStats, undefined, function (stat) { return ({ completed: (0, BaseWrapper_1.valueToInt)(stat[0]), total: (0, BaseWrapper_1.valueToInt)(stat[1]) }); });\n        _this.makeIsIssuerRunningAttestationService = function (tries) {\n            if (tries === void 0) { tries = 3; }\n            return function (arg) { return __awaiter(_this, void 0, void 0, function () {\n                var metadata, attestationServiceURLClaim, nameClaim, resp, _a, status_1, version, error_1;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _b.trys.push([0, 4, , 5]);\n                            return [4 /*yield*/, identity_1.IdentityMetadataWrapper.fetchFromURL(this.kit, arg.metadataURL, tries)];\n                        case 1:\n                            metadata = _b.sent();\n                            attestationServiceURLClaim = metadata.findClaim(identity_1.ClaimTypes.ATTESTATION_SERVICE_URL);\n                            if (attestationServiceURLClaim === undefined) {\n                                throw new Error(\"No attestation service URL registered for \" + arg.issuer);\n                            }\n                            nameClaim = metadata.findClaim(identity_1.ClaimTypes.NAME);\n                            return [4 /*yield*/, (0, cross_fetch_1.default)(\"\" + attestationServiceURLClaim.url + (attestationServiceURLClaim.url.substr(-1) === '/' ? '' : '/') + \"status\")];\n                        case 2:\n                            resp = _b.sent();\n                            if (!resp.ok) {\n                                throw new Error(\"Request failed with status \" + resp.status);\n                            }\n                            return [4 /*yield*/, resp.json()];\n                        case 3:\n                            _a = _b.sent(), status_1 = _a.status, version = _a.version;\n                            if (status_1 !== 'ok') {\n                                return [2 /*return*/, { isValid: false, issuer: arg.issuer }];\n                            }\n                            return [2 /*return*/, {\n                                    isValid: true,\n                                    result: {\n                                        blockNumber: arg.blockNumber,\n                                        issuer: arg.issuer,\n                                        attestationServiceURL: attestationServiceURLClaim.url,\n                                        name: nameClaim ? nameClaim.name : undefined,\n                                        version: version,\n                                    },\n                                }];\n                        case 4:\n                            error_1 = _b.sent();\n                            return [2 /*return*/, { isValid: false, issuer: arg.issuer }];\n                        case 5: return [2 /*return*/];\n                    }\n                });\n            }); };\n        };\n        /**\n         * Returns the attestation signer for the specified account.\n         * @param account The address of token rewards are accumulated in.\n         * @param account The address of the account.\n         * @return The reward amount.\n         */\n        _this.getPendingWithdrawals = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.pendingWithdrawals, undefined, BaseWrapper_1.valueToBigNumber);\n        /**\n         * Allows issuers to withdraw accumulated attestation rewards\n         * @param address The address of the token that will be withdrawn\n         */\n        _this.withdraw = (0, BaseWrapper_1.proxySend)(_this.kit, _this.contract.methods.withdraw);\n        /**\n         * Returns the list of accounts associated with an identifier.\n         * @param identifier Attestation identifier (e.g. phone hash)\n         */\n        _this.lookupAccountsForIdentifier = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.lookupAccountsForIdentifier);\n        /**\n         * Updates sender's approval status on whether to allow an attestation identifier\n         * mapping to be transfered from one address to another.\n         * @param identifier The identifier for this attestation.\n         * @param index The index of the account in the accounts array.\n         * @param from The current attestation address to which the identifier is mapped.\n         * @param to The new address to map to identifier.\n         * @param status The approval status\n         */\n        _this.approveTransfer = (0, BaseWrapper_1.proxySend)(_this.kit, _this.contract.methods.approveTransfer);\n        return _this;\n    }\n    /**\n     * Returns the verified status of an identifier/account pair indicating whether the attestation\n     * stats for a given pair are completed beyond a certain threshold of confidence (aka \"verified\")\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param account Address of the account\n     * @param numAttestationsRequired Optional number of attestations required.  Will default to\n     *  hardcoded value if absent.\n     * @param attestationThreshold Optional threshold for fraction attestations completed. Will\n     *  default to hardcoded value if absent.\n     */\n    AttestationsWrapper.prototype.getVerifiedStatus = function (identifier, account, numAttestationsRequired, attestationThreshold) {\n        return __awaiter(this, void 0, void 0, function () {\n            var attestationStats;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getAttestationStat(identifier, account)];\n                    case 1:\n                        attestationStats = _a.sent();\n                        return [2 /*return*/, lib_1.AttestationUtils.isAccountConsideredVerified(attestationStats, numAttestationsRequired, attestationThreshold)];\n                }\n            });\n        });\n    };\n    /**\n     * Calculates the amount of StableToken required to request Attestations\n     * @param attestationsRequested  The number of attestations to request\n     */\n    AttestationsWrapper.prototype.getAttestationFeeRequired = function (attestationsRequested) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tokenAddress, attestationFee;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.kit.registry.addressFor(base_1.CeloContract.StableToken)];\n                    case 1:\n                        tokenAddress = _a.sent();\n                        return [4 /*yield*/, this.contract.methods.getAttestationRequestFee(tokenAddress).call()];\n                    case 2:\n                        attestationFee = _a.sent();\n                        return [2 /*return*/, new bignumber_js_1.default(attestationFee).times(attestationsRequested)];\n                }\n            });\n        });\n    };\n    /**\n     * Approves the necessary amount of StableToken to request Attestations\n     * @param attestationsRequested The number of attestations to request\n     */\n    AttestationsWrapper.prototype.approveAttestationFee = function (attestationsRequested) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tokenContract, fee;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.kit.contracts.getContract(base_1.CeloContract.StableToken)];\n                    case 1:\n                        tokenContract = _a.sent();\n                        return [4 /*yield*/, this.getAttestationFeeRequired(attestationsRequested)];\n                    case 2:\n                        fee = _a.sent();\n                        return [2 /*return*/, tokenContract.approve(this.address, fee.toFixed())];\n                }\n            });\n        });\n    };\n    /**\n     * Returns an array of attestations that can be completed, along with the issuers' attestation\n     * service urls\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param account Address of the account\n     */\n    AttestationsWrapper.prototype.getActionableAttestations = function (identifier, account, tries) {\n        if (tries === void 0) { tries = 3; }\n        return __awaiter(this, void 0, void 0, function () {\n            var result, results;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.contract.methods\n                            .getCompletableAttestations(identifier, account)\n                            .call()];\n                    case 1:\n                        result = _a.sent();\n                        return [4 /*yield*/, (0, async_1.concurrentMap)(5, parseGetCompletableAttestations(result), this.makeIsIssuerRunningAttestationService(tries))];\n                    case 2:\n                        results = _a.sent();\n                        return [2 /*return*/, results.map(function (_) { return (_.isValid ? _.result : null); }).filter(collections_1.notEmpty)];\n                }\n            });\n        });\n    };\n    /**\n     * Returns an array of issuer addresses that were found to not run the attestation service\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param account Address of the account\n     */\n    AttestationsWrapper.prototype.getNonCompliantIssuers = function (identifier, account, tries) {\n        if (tries === void 0) { tries = 3; }\n        return __awaiter(this, void 0, void 0, function () {\n            var result, withAttestationServiceURLs;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.contract.methods\n                            .getCompletableAttestations(identifier, account)\n                            .call()];\n                    case 1:\n                        result = _a.sent();\n                        return [4 /*yield*/, (0, async_1.concurrentMap)(5, parseGetCompletableAttestations(result), this.makeIsIssuerRunningAttestationService(tries))];\n                    case 2:\n                        withAttestationServiceURLs = _a.sent();\n                        return [2 /*return*/, withAttestationServiceURLs.map(function (_) { return (_.isValid ? null : _.issuer); }).filter(collections_1.notEmpty)];\n                }\n            });\n        });\n    };\n    /**\n     * Completes an attestation with the corresponding code\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param account Address of the account\n     * @param issuer The issuer of the attestation\n     * @param code The code received by the validator\n     */\n    AttestationsWrapper.prototype.complete = function (identifier, account, issuer, code) {\n        return __awaiter(this, void 0, void 0, function () {\n            var accounts, attestationSigner, expectedSourceMessage, _a, r, s, v;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this.kit.contracts.getAccounts()];\n                    case 1:\n                        accounts = _b.sent();\n                        return [4 /*yield*/, accounts.getAttestationSigner(issuer)];\n                    case 2:\n                        attestationSigner = _b.sent();\n                        expectedSourceMessage = lib_1.AttestationUtils.getAttestationMessageToSignFromIdentifier(identifier, account);\n                        _a = lib_1.SignatureUtils.parseSignature(expectedSourceMessage, code, attestationSigner), r = _a.r, s = _a.s, v = _a.v;\n                        return [2 /*return*/, (0, connect_1.toTransactionObject)(this.kit.connection, this.contract.methods.complete(identifier, v, r, s))];\n                }\n            });\n        });\n    };\n    /**\n     * Given a list of issuers, finds the matching issuer for a given code\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param account Address of the account\n     * @param code The code received by the validator\n     * @param issuers The list of potential issuers\n     */\n    AttestationsWrapper.prototype.findMatchingIssuer = function (identifier, account, code, issuers) {\n        return __awaiter(this, void 0, void 0, function () {\n            var accounts, expectedSourceMessage, _i, issuers_1, issuer, attestationSigner;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.kit.contracts.getAccounts()];\n                    case 1:\n                        accounts = _a.sent();\n                        expectedSourceMessage = lib_1.AttestationUtils.getAttestationMessageToSignFromIdentifier(identifier, account);\n                        _i = 0, issuers_1 = issuers;\n                        _a.label = 2;\n                    case 2:\n                        if (!(_i < issuers_1.length)) return [3 /*break*/, 5];\n                        issuer = issuers_1[_i];\n                        return [4 /*yield*/, accounts.getAttestationSigner(issuer)];\n                    case 3:\n                        attestationSigner = _a.sent();\n                        try {\n                            lib_1.SignatureUtils.parseSignature(expectedSourceMessage, code, attestationSigner);\n                            return [2 /*return*/, issuer];\n                        }\n                        catch (error) {\n                            return [3 /*break*/, 4];\n                        }\n                        _a.label = 4;\n                    case 4:\n                        _i++;\n                        return [3 /*break*/, 2];\n                    case 5: return [2 /*return*/, null];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the current configuration parameters for the contract.\n     * @param tokens List of tokens used for attestation fees.\n     * @return AttestationsConfig object\n     */\n    AttestationsWrapper.prototype.getConfig = function (tokens) {\n        return __awaiter(this, void 0, void 0, function () {\n            var feeTokens, _a, _b, _c, fees;\n            var _d;\n            var _this = this;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        if (!(tokens !== null && tokens !== void 0)) return [3 /*break*/, 1];\n                        _a = tokens;\n                        return [3 /*break*/, 3];\n                    case 1:\n                        _c = (_b = Object).values;\n                        return [4 /*yield*/, this.kit.celoTokens.getAddresses()];\n                    case 2:\n                        _a = _c.apply(_b, [_e.sent()]);\n                        _e.label = 3;\n                    case 3:\n                        feeTokens = _a;\n                        return [4 /*yield*/, Promise.all(feeTokens.map(function (token) { return __awaiter(_this, void 0, void 0, function () {\n                                var fee;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4 /*yield*/, this.attestationRequestFees(token)];\n                                        case 1:\n                                            fee = _a.sent();\n                                            return [2 /*return*/, { fee: fee, address: token }];\n                                    }\n                                });\n                            }); }))];\n                    case 4:\n                        fees = _e.sent();\n                        _d = {};\n                        return [4 /*yield*/, this.attestationExpiryBlocks()];\n                    case 5: return [2 /*return*/, (_d.attestationExpiryBlocks = _e.sent(),\n                            _d.attestationRequestFees = fees,\n                            _d)];\n                }\n            });\n        });\n    };\n    /**\n     * @dev Returns human readable configuration of the attestations contract\n     * @return AttestationsConfig object\n     */\n    AttestationsWrapper.prototype.getHumanReadableConfig = function (tokens) {\n        return __awaiter(this, void 0, void 0, function () {\n            var config;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getConfig(tokens)];\n                    case 1:\n                        config = _a.sent();\n                        return [2 /*return*/, {\n                                attestationRequestFees: config.attestationRequestFees,\n                                attestationExpiry: (0, BaseWrapper_1.blocksToDurationString)(config.attestationExpiryBlocks),\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Lookup mapped wallet addresses for a given list of identifiers\n     * @param identifiers Attestation identifiers (e.g. phone hashes)\n     */\n    AttestationsWrapper.prototype.lookupIdentifiers = function (identifiers) {\n        return __awaiter(this, void 0, void 0, function () {\n            var stats, matches, addresses, completed, total, result, rIndex, pIndex, pHash, numberOfMatches, matchingAddresses, mIndex, matchingAddress;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.contract.methods.batchGetAttestationStats(identifiers).call()];\n                    case 1:\n                        stats = _a.sent();\n                        matches = stats[0].map(BaseWrapper_1.valueToInt);\n                        addresses = stats[1];\n                        completed = stats[2].map(BaseWrapper_1.valueToInt);\n                        total = stats[3].map(BaseWrapper_1.valueToInt);\n                        result = {};\n                        rIndex = 0;\n                        for (pIndex = 0; pIndex < identifiers.length; pIndex++) {\n                            pHash = identifiers[pIndex];\n                            numberOfMatches = matches[pIndex];\n                            if (numberOfMatches === 0) {\n                                continue;\n                            }\n                            matchingAddresses = {};\n                            for (mIndex = 0; mIndex < numberOfMatches; mIndex++) {\n                                matchingAddress = addresses[rIndex];\n                                matchingAddresses[matchingAddress] = {\n                                    completed: completed[rIndex],\n                                    total: total[rIndex],\n                                };\n                                rIndex++;\n                            }\n                            result[pHash] = matchingAddresses;\n                        }\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    /**\n     * Requests a new attestation\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param attestationsRequested The number of attestations to request\n     */\n    AttestationsWrapper.prototype.request = function (identifier, attestationsRequested) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tokenAddress;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.kit.registry.addressFor(base_1.CeloContract.StableToken)];\n                    case 1:\n                        tokenAddress = _a.sent();\n                        return [2 /*return*/, (0, connect_1.toTransactionObject)(this.kit.connection, this.contract.methods.request(identifier, attestationsRequested, tokenAddress))];\n                }\n            });\n        });\n    };\n    /**\n     * Selects the issuers for previously requested attestations for a phone number\n     * @param identifier Attestation identifier (e.g. phone hash)\n     */\n    AttestationsWrapper.prototype.selectIssuers = function (identifier) {\n        return (0, connect_1.toTransactionObject)(this.kit.connection, this.contract.methods.selectIssuers(identifier));\n    };\n    /**\n     * Waits appropriate number of blocks, then selects issuers for previously requested phone number attestations\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param account Address of the account\n     */\n    AttestationsWrapper.prototype.selectIssuersAfterWait = function (identifier, account, timeoutSeconds, pollDurationSeconds) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.waitForSelectingIssuers(identifier, account, timeoutSeconds, pollDurationSeconds)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, this.selectIssuers(identifier)];\n                }\n            });\n        });\n    };\n    /**\n     * Reveal phone number to issuer\n     * @param serviceURL: validator's attestation service URL\n     * @param body\n     */\n    AttestationsWrapper.prototype.revealPhoneNumberToIssuer = function (serviceURL, requestBody) {\n        return (0, cross_fetch_1.default)((0, string_1.appendPath)(serviceURL, 'attestations'), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(requestBody),\n        });\n    };\n    /**\n     * Returns reveal status from validator's attestation service\n     * @param phoneNumber: attestation's phone number\n     * @param account: attestation's account\n     * @param issuer: validator's address\n     * @param serviceURL: validator's attestation service URL\n     * @param pepper: phone number privacy pepper\n     */\n    AttestationsWrapper.prototype.getRevealStatus = function (phoneNumber, account, issuer, serviceURL, pepper) {\n        var urlParams = new URLSearchParams({\n            phoneNumber: phoneNumber,\n            salt: pepper !== null && pepper !== void 0 ? pepper : '',\n            issuer: issuer,\n            account: account,\n        });\n        return (0, cross_fetch_1.default)((0, string_1.appendPath)(serviceURL, 'get_attestations') + '?' + urlParams, {\n            method: 'GET',\n            headers: { 'Content-Type': 'application/json' },\n        });\n    };\n    /**\n     * Returns attestation code for provided security code from validator's attestation service\n     * @param serviceURL: validator's attestation service URL\n     * @param body\n     */\n    AttestationsWrapper.prototype.getAttestationForSecurityCode = function (serviceURL, requestBody, signer) {\n        return __awaiter(this, void 0, void 0, function () {\n            var urlParams, additionalHeaders, signature, response, ok, status, body, _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        urlParams = new URLSearchParams({\n                            phoneNumber: requestBody.phoneNumber,\n                            account: requestBody.account,\n                            issuer: requestBody.issuer,\n                        });\n                        additionalHeaders = {};\n                        if (requestBody.salt) {\n                            urlParams.set('salt', requestBody.salt);\n                        }\n                        if (!requestBody.securityCode) return [3 /*break*/, 2];\n                        urlParams.set('securityCode', requestBody.securityCode);\n                        return [4 /*yield*/, this.kit.signTypedData(signer, (0, typed_data_constructors_1.attestationSecurityCode)(requestBody.securityCode))];\n                    case 1:\n                        signature = _c.sent();\n                        additionalHeaders = {\n                            Authentication: lib_1.SignatureUtils.serializeSignature(signature),\n                        };\n                        _c.label = 2;\n                    case 2: return [4 /*yield*/, (0, cross_fetch_1.default)((0, string_1.appendPath)(serviceURL, 'get_attestations') + '?' + urlParams, {\n                            method: 'GET',\n                            headers: __assign({ 'Content-Type': 'application/json' }, additionalHeaders),\n                        })];\n                    case 3:\n                        response = _c.sent();\n                        ok = response.ok, status = response.status;\n                        if (!ok) return [3 /*break*/, 5];\n                        return [4 /*yield*/, response.json()];\n                    case 4:\n                        body = _c.sent();\n                        if (body.attestationCode) {\n                            return [2 /*return*/, body.attestationCode];\n                        }\n                        _c.label = 5;\n                    case 5:\n                        _a = Error.bind;\n                        _b = \"Error getting security code for \" + requestBody.issuer + \". \" + status + \": \";\n                        return [4 /*yield*/, response.text()];\n                    case 6: throw new (_a.apply(Error, [void 0, _b + (_c.sent())]))();\n                }\n            });\n        });\n    };\n    /**\n     * Validates a given code by the issuer on-chain\n     * @param identifier Attestation identifier (e.g. phone hash)\n     * @param account The address of the account which requested attestation\n     * @param issuer The address of the issuer of the attestation\n     * @param code The code send by the issuer\n     */\n    AttestationsWrapper.prototype.validateAttestationCode = function (identifier, account, issuer, code) {\n        return __awaiter(this, void 0, void 0, function () {\n            var accounts, attestationSigner, expectedSourceMessage, _a, r, s, v, result;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this.kit.contracts.getAccounts()];\n                    case 1:\n                        accounts = _b.sent();\n                        return [4 /*yield*/, accounts.getAttestationSigner(issuer)];\n                    case 2:\n                        attestationSigner = _b.sent();\n                        expectedSourceMessage = lib_1.AttestationUtils.getAttestationMessageToSignFromIdentifier(identifier, account);\n                        _a = lib_1.SignatureUtils.parseSignature(expectedSourceMessage, code, attestationSigner), r = _a.r, s = _a.s, v = _a.v;\n                        return [4 /*yield*/, this.contract.methods\n                                .validateAttestationCode(identifier, account, v, r, s)\n                                .call()];\n                    case 3:\n                        result = _b.sent();\n                        return [2 /*return*/, result.toLowerCase() !== address_1.NULL_ADDRESS];\n                }\n            });\n        });\n    };\n    /**\n     * Gets the relevant attestation service status for a validator\n     * @param validator Validator to get the attestation service status for\n     */\n    AttestationsWrapper.prototype.getAttestationServiceStatus = function (validator) {\n        return __awaiter(this, void 0, void 0, function () {\n            var accounts, hasAttestationSigner, attestationSigner, attestationServiceURL, ret, metadataURL, metadata, attestationServiceURLClaim, error_2, statusResponse, statusResponseBody, healthzResponse, healthzResponseBody, error_3, error_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.kit.contracts.getAccounts()];\n                    case 1:\n                        accounts = _a.sent();\n                        return [4 /*yield*/, accounts.hasAuthorizedAttestationSigner(validator.address)];\n                    case 2:\n                        hasAttestationSigner = _a.sent();\n                        return [4 /*yield*/, accounts.getAttestationSigner(validator.address)];\n                    case 3:\n                        attestationSigner = _a.sent();\n                        ret = __assign(__assign({}, validator), { hasAttestationSigner: hasAttestationSigner, attestationSigner: attestationSigner, attestationServiceURL: null, okStatus: false, error: null, smsProviders: [], blacklistedRegionCodes: [], rightAccount: false, metadataURL: null, state: AttestationServiceStatusState.NoAttestationSigner, version: null, ageOfLatestBlock: null, smsProvidersRandomized: null, maxDeliveryAttempts: null, maxRerequestMins: null, twilioVerifySidProvided: null });\n                        if (!hasAttestationSigner) {\n                            return [2 /*return*/, ret];\n                        }\n                        return [4 /*yield*/, accounts.getMetadataURL(validator.address)];\n                    case 4:\n                        metadataURL = _a.sent();\n                        ret.metadataURL = metadataURL;\n                        if (!metadataURL) {\n                            ret.state = AttestationServiceStatusState.NoMetadataURL;\n                            return [2 /*return*/, ret];\n                        }\n                        if (metadataURL.startsWith('http://')) {\n                            ret.state = AttestationServiceStatusState.InvalidAttestationServiceURL;\n                            return [2 /*return*/, ret];\n                        }\n                        _a.label = 5;\n                    case 5:\n                        _a.trys.push([5, 7, , 8]);\n                        return [4 /*yield*/, identity_1.IdentityMetadataWrapper.fetchFromURL(this.kit, metadataURL)];\n                    case 6:\n                        metadata = _a.sent();\n                        attestationServiceURLClaim = metadata.findClaim(identity_1.ClaimTypes.ATTESTATION_SERVICE_URL);\n                        if (!attestationServiceURLClaim) {\n                            ret.state = AttestationServiceStatusState.NoAttestationServiceURL;\n                            return [2 /*return*/, ret];\n                        }\n                        attestationServiceURL = attestationServiceURLClaim.url;\n                        return [3 /*break*/, 8];\n                    case 7:\n                        error_2 = _a.sent();\n                        ret.state =\n                            error_2.type === 'system'\n                                ? AttestationServiceStatusState.MetadataTimeout\n                                : AttestationServiceStatusState.InvalidMetadata;\n                        ret.error = error_2;\n                        return [2 /*return*/, ret];\n                    case 8:\n                        ret.attestationServiceURL = attestationServiceURL;\n                        _a.label = 9;\n                    case 9:\n                        _a.trys.push([9, 19, , 20]);\n                        return [4 /*yield*/, (0, cross_fetch_1.default)((0, string_1.appendPath)(attestationServiceURL, 'status'))];\n                    case 10:\n                        statusResponse = _a.sent();\n                        if (!statusResponse.ok) {\n                            ret.state = AttestationServiceStatusState.UnreachableAttestationService;\n                            return [2 /*return*/, ret];\n                        }\n                        ret.okStatus = true;\n                        return [4 /*yield*/, statusResponse.json()];\n                    case 11:\n                        statusResponseBody = _a.sent();\n                        ret.smsProviders = statusResponseBody.smsProviders;\n                        ret.rightAccount = (0, address_1.eqAddress)(validator.address, statusResponseBody.accountAddress);\n                        ret.state = ret.rightAccount\n                            ? AttestationServiceStatusState.Valid\n                            : AttestationServiceStatusState.WrongAccount;\n                        ret.ageOfLatestBlock = statusResponseBody.ageOfLatestBlock;\n                        ret.smsProvidersRandomized = statusResponseBody.smsProvidersRandomized;\n                        ret.maxDeliveryAttempts = statusResponseBody.maxDeliveryAttempts;\n                        ret.maxRerequestMins = statusResponseBody.maxRerequestMins;\n                        ret.twilioVerifySidProvided = statusResponseBody.twilioVerifySidProvided;\n                        if (!statusResponseBody.version) return [3 /*break*/, 17];\n                        ret.version = statusResponseBody.version;\n                        _a.label = 12;\n                    case 12:\n                        _a.trys.push([12, 15, , 16]);\n                        return [4 /*yield*/, (0, cross_fetch_1.default)((0, string_1.appendPath)(attestationServiceURL, 'healthz'))];\n                    case 13:\n                        healthzResponse = _a.sent();\n                        return [4 /*yield*/, healthzResponse.json()];\n                    case 14:\n                        healthzResponseBody = _a.sent();\n                        if (!healthzResponse.ok) {\n                            ret.state = AttestationServiceStatusState.Unhealthy;\n                            if (healthzResponseBody.error) {\n                                ret.error = healthzResponseBody.error;\n                            }\n                        }\n                        return [3 /*break*/, 16];\n                    case 15:\n                        error_3 = _a.sent();\n                        ret.state = AttestationServiceStatusState.UnreachableHealthz;\n                        return [3 /*break*/, 16];\n                    case 16:\n                        // Whether or not health check is reachable, also check full node status\n                        // (overrides UnreachableHealthz status)\n                        if ((statusResponseBody.ageOfLatestBlock !== null &&\n                            statusResponseBody.ageOfLatestBlock > 10) ||\n                            statusResponseBody.isNodeSyncing === true) {\n                            ret.state = AttestationServiceStatusState.Unhealthy;\n                        }\n                        return [3 /*break*/, 18];\n                    case 17:\n                        // No version implies 1.0.0\n                        ret.version = '1.0.0';\n                        _a.label = 18;\n                    case 18: return [3 /*break*/, 20];\n                    case 19:\n                        error_4 = _a.sent();\n                        ret.state = AttestationServiceStatusState.UnreachableAttestationService;\n                        ret.error = error_4;\n                        return [3 /*break*/, 20];\n                    case 20: return [2 /*return*/, ret];\n                }\n            });\n        });\n    };\n    AttestationsWrapper.prototype.revoke = function (identifer, account) {\n        return __awaiter(this, void 0, void 0, function () {\n            var accounts, idx;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.lookupAccountsForIdentifier(identifer)];\n                    case 1:\n                        accounts = _a.sent();\n                        idx = accounts.findIndex(function (acc) { return (0, address_1.eqAddress)(acc, account); });\n                        if (idx < 0) {\n                            throw new Error(\"Account not found in identifier's accounts\");\n                        }\n                        return [2 /*return*/, (0, connect_1.toTransactionObject)(this.kit.connection, this.contract.methods.revoke(identifer, idx))];\n                }\n            });\n        });\n    };\n    return AttestationsWrapper;\n}(BaseWrapper_1.BaseWrapper));\nexports.AttestationsWrapper = AttestationsWrapper;\nvar AttestationServiceStatusState;\n(function (AttestationServiceStatusState) {\n    AttestationServiceStatusState[\"NoAttestationSigner\"] = \"NoAttestationSigner\";\n    AttestationServiceStatusState[\"NoMetadataURL\"] = \"NoMetadataURL\";\n    AttestationServiceStatusState[\"InvalidMetadata\"] = \"InvalidMetadata\";\n    AttestationServiceStatusState[\"NoAttestationServiceURL\"] = \"NoAttestationServiceURL\";\n    AttestationServiceStatusState[\"InvalidAttestationServiceURL\"] = \"InvalidAttestationServiceURL\";\n    AttestationServiceStatusState[\"UnreachableAttestationService\"] = \"UnreachableAttestationService\";\n    AttestationServiceStatusState[\"Valid\"] = \"Valid\";\n    AttestationServiceStatusState[\"UnreachableHealthz\"] = \"UnreachableHealthz\";\n    AttestationServiceStatusState[\"Unhealthy\"] = \"Unhealthy\";\n    AttestationServiceStatusState[\"WrongAccount\"] = \"WrongAccount\";\n    AttestationServiceStatusState[\"MetadataTimeout\"] = \"MetadataTimeout\";\n})(AttestationServiceStatusState = exports.AttestationServiceStatusState || (exports.AttestationServiceStatusState = {}));\n//# sourceMappingURL=Attestations.js.map"]},"metadata":{},"sourceType":"script"}