{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CeloProvider = exports.assertIsCeloProvider = void 0;\n\nvar lock_1 = require(\"@celo/base/lib/lock\");\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar provider_utils_1 = require(\"./utils/provider-utils\");\n\nvar rpc_caller_1 = require(\"./utils/rpc-caller\");\n\nvar debug = (0, debug_1.default)('provider:connection');\nvar debugPayload = (0, debug_1.default)('provider:payload');\nvar debugTxToSend = (0, debug_1.default)('provider:tx-to-send');\nvar debugEncodedTx = (0, debug_1.default)('provider:encoded-tx');\nvar debugResponse = (0, debug_1.default)('provider:response');\nvar InterceptedMethods;\n\n(function (InterceptedMethods) {\n  InterceptedMethods[\"accounts\"] = \"eth_accounts\";\n  InterceptedMethods[\"sendTransaction\"] = \"eth_sendTransaction\";\n  InterceptedMethods[\"signTransaction\"] = \"eth_signTransaction\";\n  InterceptedMethods[\"sign\"] = \"eth_sign\";\n  InterceptedMethods[\"personalSign\"] = \"personal_sign\";\n  InterceptedMethods[\"signTypedData\"] = \"eth_signTypedData\";\n})(InterceptedMethods || (InterceptedMethods = {}));\n\nfunction assertIsCeloProvider(provider) {\n  if (!(provider instanceof CeloProvider)) {\n    throw new Error('A different Provider was manually added to the kit. The kit should have a CeloProvider');\n  }\n}\n\nexports.assertIsCeloProvider = assertIsCeloProvider;\n\nvar CeloProvider =\n/** @class */\nfunction () {\n  function CeloProvider(existingProvider, connection) {\n    this.existingProvider = existingProvider;\n    this.connection = connection;\n    this.alreadyStopped = false; // Transaction nonce is calculated as the max of an account's nonce on-chain, and any pending transactions in a node's\n    // transaction pool. As a result, once a nonce is used, the transaction must be sent to the node before the nonce can\n    // be calculated for another transaction. In particular the sign and send operation must be completed atomically with\n    // relation to other sign and send operations.\n\n    this.nonceLock = new lock_1.Lock();\n    this.addProviderDelegatedFunctions();\n  } // Used for backwards compatibility. Use the `addAccount` from the Connection\n\n\n  CeloProvider.prototype.addAccount = function (privateKey) {\n    this.connection.addAccount(privateKey);\n  }; // Used for backwards compatibility. Use the `removeAccount` from the Connection\n\n\n  CeloProvider.prototype.removeAccount = function (address) {\n    this.connection.removeAccount(address);\n  }; // Used for backwards compatibility. Use the `getAccounts` from the Connection\n\n\n  CeloProvider.prototype.getAccounts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.connection.getAccounts()];\n      });\n    });\n  };\n\n  CeloProvider.prototype.isLocalAccount = function (address) {\n    return this.connection.wallet != null && this.connection.wallet.hasAccount(address);\n  };\n  /**\n   * Send method as expected by web3.js\n   */\n\n\n  CeloProvider.prototype.send = function (payload, callback) {\n    var txParams;\n    var address;\n    debugPayload('%O', payload);\n\n    var decoratedCallback = function (error, result) {\n      debugResponse('%O', result);\n      callback(error, result);\n    };\n\n    if (this.alreadyStopped) {\n      throw Error('CeloProvider already stopped');\n    }\n\n    switch (payload.method) {\n      case InterceptedMethods.accounts:\n        {\n          (0, rpc_caller_1.rpcCallHandler)(payload, this.handleAccounts.bind(this), decoratedCallback);\n          return;\n        }\n\n      case InterceptedMethods.sendTransaction:\n        {\n          this.checkPayloadWithAtLeastNParams(payload, 1);\n          txParams = payload.params[0];\n\n          if (this.connection.isLocalAccount(txParams.from)) {\n            (0, rpc_caller_1.rpcCallHandler)(payload, this.handleSendTransaction.bind(this), decoratedCallback);\n          } else {\n            this.forwardSend(payload, callback);\n          }\n\n          return;\n        }\n\n      case InterceptedMethods.signTransaction:\n        {\n          this.checkPayloadWithAtLeastNParams(payload, 1);\n          txParams = payload.params[0];\n\n          if (this.connection.isLocalAccount(txParams.from)) {\n            (0, rpc_caller_1.rpcCallHandler)(payload, this.handleSignTransaction.bind(this), decoratedCallback);\n          } else {\n            this.forwardSend(payload, callback);\n          }\n\n          return;\n        }\n\n      case InterceptedMethods.sign:\n      case InterceptedMethods.personalSign:\n        {\n          this.checkPayloadWithAtLeastNParams(payload, 2);\n          address = payload.method === InterceptedMethods.sign ? payload.params[0] : payload.params[1];\n\n          if (this.connection.isLocalAccount(address)) {\n            (0, rpc_caller_1.rpcCallHandler)(payload, this.handleSignPersonalMessage.bind(this), decoratedCallback);\n          } else {\n            this.forwardSend(payload, callback);\n          }\n\n          return;\n        }\n\n      case InterceptedMethods.signTypedData:\n        {\n          this.checkPayloadWithAtLeastNParams(payload, 1);\n          address = payload.params[0];\n\n          if (this.connection.isLocalAccount(address)) {\n            (0, rpc_caller_1.rpcCallHandler)(payload, this.handleSignTypedData.bind(this), decoratedCallback);\n          } else {\n            this.forwardSend(payload, callback);\n          }\n\n          return;\n        }\n\n      default:\n        {\n          this.forwardSend(payload, callback);\n          return;\n        }\n    }\n  };\n\n  CeloProvider.prototype.stop = function () {\n    if (this.alreadyStopped) {\n      return;\n    }\n\n    try {\n      (0, provider_utils_1.stopProvider)(this.existingProvider);\n      this.alreadyStopped = true;\n    } catch (error) {\n      debug(\"Failed to close the connection: \" + error);\n    }\n  };\n\n  CeloProvider.prototype.handleAccounts = function (_payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.connection.getAccounts()];\n      });\n    });\n  };\n\n  CeloProvider.prototype.handleSignTypedData = function (payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, address, typedData, signature;\n\n      return __generator(this, function (_b) {\n        _a = payload.params, address = _a[0], typedData = _a[1];\n        signature = this.connection.wallet.signTypedData(address, typedData);\n        return [2\n        /*return*/\n        , signature];\n      });\n    });\n  };\n\n  CeloProvider.prototype.handleSignPersonalMessage = function (payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var address, data, ecSignatureHex;\n      return __generator(this, function (_a) {\n        address = payload.method === 'eth_sign' ? payload.params[0] : payload.params[1];\n        data = payload.method === 'eth_sign' ? payload.params[1] : payload.params[0];\n        ecSignatureHex = this.connection.wallet.signPersonalMessage(address, data);\n        return [2\n        /*return*/\n        , ecSignatureHex];\n      });\n    });\n  };\n\n  CeloProvider.prototype.handleSignTransaction = function (payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var txParams, filledParams, signedTx;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            txParams = payload.params[0];\n            return [4\n            /*yield*/\n            , this.connection.paramsPopulator.populate(txParams)];\n\n          case 1:\n            filledParams = _a.sent();\n            debugTxToSend('%O', filledParams);\n            return [4\n            /*yield*/\n            , this.connection.wallet.signTransaction(filledParams)];\n\n          case 2:\n            signedTx = _a.sent();\n            debugEncodedTx('%O', signedTx);\n            return [2\n            /*return*/\n            , signedTx];\n        }\n      });\n    });\n  };\n\n  CeloProvider.prototype.handleSendTransaction = function (payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signedTx, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.nonceLock.acquire()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2,, 5, 6]);\n\n            return [4\n            /*yield*/\n            , this.handleSignTransaction(payload)];\n\n          case 3:\n            signedTx = _a.sent();\n            return [4\n            /*yield*/\n            , this.connection.rpcCaller.call('eth_sendRawTransaction', [signedTx.raw])];\n\n          case 4:\n            response = _a.sent();\n            return [2\n            /*return*/\n            , response.result];\n\n          case 5:\n            this.nonceLock.release();\n            return [7\n            /*endfinally*/\n            ];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  CeloProvider.prototype.forwardSend = function (payload, callback) {\n    this.connection.rpcCaller.send(payload, callback);\n  };\n\n  CeloProvider.prototype.checkPayloadWithAtLeastNParams = function (payload, n) {\n    if (!payload.params || payload.params.length < n) {\n      throw Error('Invalid params');\n    }\n  }; // Functions required to act as a delefator for the existingProvider\n\n\n  CeloProvider.prototype.addProviderDelegatedFunctions = function () {\n    if ((0, provider_utils_1.hasProperty)(this.existingProvider, 'on')) {\n      // @ts-ignore\n      this.on = this.defaultOn;\n    }\n\n    if ((0, provider_utils_1.hasProperty)(this.existingProvider, 'once')) {\n      // @ts-ignore\n      this.once = this.defaultOnce;\n    }\n\n    if ((0, provider_utils_1.hasProperty)(this.existingProvider, 'removeListener')) {\n      // @ts-ignore\n      this.removeListener = this.defaultRemoveListener;\n    }\n\n    if ((0, provider_utils_1.hasProperty)(this.existingProvider, 'removeAllListener')) {\n      // @ts-ignore\n      this.removeAllListener = this.defaultRemoveAllListeners;\n    }\n\n    if ((0, provider_utils_1.hasProperty)(this.existingProvider, 'reset')) {\n      // @ts-ignore\n      this.reset = this.defaultReset;\n    }\n  };\n\n  Object.defineProperty(CeloProvider.prototype, \"connected\", {\n    get: function () {\n      return this.existingProvider.connected;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  CeloProvider.prototype.supportsSubscriptions = function () {\n    return this.existingProvider.supportsSubscriptions();\n  };\n\n  CeloProvider.prototype.defaultOn = function (type, callback) {\n    ;\n    this.existingProvider.on(type, callback);\n  };\n\n  CeloProvider.prototype.defaultOnce = function (type, callback) {\n    ;\n    this.existingProvider.once(type, callback);\n  };\n\n  CeloProvider.prototype.defaultRemoveListener = function (type, callback) {\n    ;\n    this.existingProvider.removeListener(type, callback);\n  };\n\n  CeloProvider.prototype.defaultRemoveAllListeners = function (type) {\n    ;\n    this.existingProvider.removeAllListeners(type);\n  };\n\n  CeloProvider.prototype.defaultReset = function () {\n    ;\n    this.existingProvider.reset();\n  };\n\n  return CeloProvider;\n}();\n\nexports.CeloProvider = CeloProvider;","map":{"version":3,"sources":["../src/celo-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CeloProvider = exports.assertIsCeloProvider = void 0;\nvar lock_1 = require(\"@celo/base/lib/lock\");\nvar debug_1 = __importDefault(require(\"debug\"));\nvar provider_utils_1 = require(\"./utils/provider-utils\");\nvar rpc_caller_1 = require(\"./utils/rpc-caller\");\nvar debug = (0, debug_1.default)('provider:connection');\nvar debugPayload = (0, debug_1.default)('provider:payload');\nvar debugTxToSend = (0, debug_1.default)('provider:tx-to-send');\nvar debugEncodedTx = (0, debug_1.default)('provider:encoded-tx');\nvar debugResponse = (0, debug_1.default)('provider:response');\nvar InterceptedMethods;\n(function (InterceptedMethods) {\n    InterceptedMethods[\"accounts\"] = \"eth_accounts\";\n    InterceptedMethods[\"sendTransaction\"] = \"eth_sendTransaction\";\n    InterceptedMethods[\"signTransaction\"] = \"eth_signTransaction\";\n    InterceptedMethods[\"sign\"] = \"eth_sign\";\n    InterceptedMethods[\"personalSign\"] = \"personal_sign\";\n    InterceptedMethods[\"signTypedData\"] = \"eth_signTypedData\";\n})(InterceptedMethods || (InterceptedMethods = {}));\nfunction assertIsCeloProvider(provider) {\n    if (!(provider instanceof CeloProvider)) {\n        throw new Error('A different Provider was manually added to the kit. The kit should have a CeloProvider');\n    }\n}\nexports.assertIsCeloProvider = assertIsCeloProvider;\nvar CeloProvider = /** @class */ (function () {\n    function CeloProvider(existingProvider, connection) {\n        this.existingProvider = existingProvider;\n        this.connection = connection;\n        this.alreadyStopped = false;\n        // Transaction nonce is calculated as the max of an account's nonce on-chain, and any pending transactions in a node's\n        // transaction pool. As a result, once a nonce is used, the transaction must be sent to the node before the nonce can\n        // be calculated for another transaction. In particular the sign and send operation must be completed atomically with\n        // relation to other sign and send operations.\n        this.nonceLock = new lock_1.Lock();\n        this.addProviderDelegatedFunctions();\n    }\n    // Used for backwards compatibility. Use the `addAccount` from the Connection\n    CeloProvider.prototype.addAccount = function (privateKey) {\n        this.connection.addAccount(privateKey);\n    };\n    // Used for backwards compatibility. Use the `removeAccount` from the Connection\n    CeloProvider.prototype.removeAccount = function (address) {\n        this.connection.removeAccount(address);\n    };\n    // Used for backwards compatibility. Use the `getAccounts` from the Connection\n    CeloProvider.prototype.getAccounts = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.connection.getAccounts()];\n            });\n        });\n    };\n    CeloProvider.prototype.isLocalAccount = function (address) {\n        return this.connection.wallet != null && this.connection.wallet.hasAccount(address);\n    };\n    /**\n     * Send method as expected by web3.js\n     */\n    CeloProvider.prototype.send = function (payload, callback) {\n        var txParams;\n        var address;\n        debugPayload('%O', payload);\n        var decoratedCallback = function (error, result) {\n            debugResponse('%O', result);\n            callback(error, result);\n        };\n        if (this.alreadyStopped) {\n            throw Error('CeloProvider already stopped');\n        }\n        switch (payload.method) {\n            case InterceptedMethods.accounts: {\n                (0, rpc_caller_1.rpcCallHandler)(payload, this.handleAccounts.bind(this), decoratedCallback);\n                return;\n            }\n            case InterceptedMethods.sendTransaction: {\n                this.checkPayloadWithAtLeastNParams(payload, 1);\n                txParams = payload.params[0];\n                if (this.connection.isLocalAccount(txParams.from)) {\n                    (0, rpc_caller_1.rpcCallHandler)(payload, this.handleSendTransaction.bind(this), decoratedCallback);\n                }\n                else {\n                    this.forwardSend(payload, callback);\n                }\n                return;\n            }\n            case InterceptedMethods.signTransaction: {\n                this.checkPayloadWithAtLeastNParams(payload, 1);\n                txParams = payload.params[0];\n                if (this.connection.isLocalAccount(txParams.from)) {\n                    (0, rpc_caller_1.rpcCallHandler)(payload, this.handleSignTransaction.bind(this), decoratedCallback);\n                }\n                else {\n                    this.forwardSend(payload, callback);\n                }\n                return;\n            }\n            case InterceptedMethods.sign:\n            case InterceptedMethods.personalSign: {\n                this.checkPayloadWithAtLeastNParams(payload, 2);\n                address = payload.method === InterceptedMethods.sign ? payload.params[0] : payload.params[1];\n                if (this.connection.isLocalAccount(address)) {\n                    (0, rpc_caller_1.rpcCallHandler)(payload, this.handleSignPersonalMessage.bind(this), decoratedCallback);\n                }\n                else {\n                    this.forwardSend(payload, callback);\n                }\n                return;\n            }\n            case InterceptedMethods.signTypedData: {\n                this.checkPayloadWithAtLeastNParams(payload, 1);\n                address = payload.params[0];\n                if (this.connection.isLocalAccount(address)) {\n                    (0, rpc_caller_1.rpcCallHandler)(payload, this.handleSignTypedData.bind(this), decoratedCallback);\n                }\n                else {\n                    this.forwardSend(payload, callback);\n                }\n                return;\n            }\n            default: {\n                this.forwardSend(payload, callback);\n                return;\n            }\n        }\n    };\n    CeloProvider.prototype.stop = function () {\n        if (this.alreadyStopped) {\n            return;\n        }\n        try {\n            (0, provider_utils_1.stopProvider)(this.existingProvider);\n            this.alreadyStopped = true;\n        }\n        catch (error) {\n            debug(\"Failed to close the connection: \" + error);\n        }\n    };\n    CeloProvider.prototype.handleAccounts = function (_payload) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.connection.getAccounts()];\n            });\n        });\n    };\n    CeloProvider.prototype.handleSignTypedData = function (payload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, address, typedData, signature;\n            return __generator(this, function (_b) {\n                _a = payload.params, address = _a[0], typedData = _a[1];\n                signature = this.connection.wallet.signTypedData(address, typedData);\n                return [2 /*return*/, signature];\n            });\n        });\n    };\n    CeloProvider.prototype.handleSignPersonalMessage = function (payload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var address, data, ecSignatureHex;\n            return __generator(this, function (_a) {\n                address = payload.method === 'eth_sign' ? payload.params[0] : payload.params[1];\n                data = payload.method === 'eth_sign' ? payload.params[1] : payload.params[0];\n                ecSignatureHex = this.connection.wallet.signPersonalMessage(address, data);\n                return [2 /*return*/, ecSignatureHex];\n            });\n        });\n    };\n    CeloProvider.prototype.handleSignTransaction = function (payload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var txParams, filledParams, signedTx;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        txParams = payload.params[0];\n                        return [4 /*yield*/, this.connection.paramsPopulator.populate(txParams)];\n                    case 1:\n                        filledParams = _a.sent();\n                        debugTxToSend('%O', filledParams);\n                        return [4 /*yield*/, this.connection.wallet.signTransaction(filledParams)];\n                    case 2:\n                        signedTx = _a.sent();\n                        debugEncodedTx('%O', signedTx);\n                        return [2 /*return*/, signedTx];\n                }\n            });\n        });\n    };\n    CeloProvider.prototype.handleSendTransaction = function (payload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var signedTx, response;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.nonceLock.acquire()];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, , 5, 6]);\n                        return [4 /*yield*/, this.handleSignTransaction(payload)];\n                    case 3:\n                        signedTx = _a.sent();\n                        return [4 /*yield*/, this.connection.rpcCaller.call('eth_sendRawTransaction', [\n                                signedTx.raw,\n                            ])];\n                    case 4:\n                        response = _a.sent();\n                        return [2 /*return*/, response.result];\n                    case 5:\n                        this.nonceLock.release();\n                        return [7 /*endfinally*/];\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CeloProvider.prototype.forwardSend = function (payload, callback) {\n        this.connection.rpcCaller.send(payload, callback);\n    };\n    CeloProvider.prototype.checkPayloadWithAtLeastNParams = function (payload, n) {\n        if (!payload.params || payload.params.length < n) {\n            throw Error('Invalid params');\n        }\n    };\n    // Functions required to act as a delefator for the existingProvider\n    CeloProvider.prototype.addProviderDelegatedFunctions = function () {\n        if ((0, provider_utils_1.hasProperty)(this.existingProvider, 'on')) {\n            // @ts-ignore\n            this.on = this.defaultOn;\n        }\n        if ((0, provider_utils_1.hasProperty)(this.existingProvider, 'once')) {\n            // @ts-ignore\n            this.once = this.defaultOnce;\n        }\n        if ((0, provider_utils_1.hasProperty)(this.existingProvider, 'removeListener')) {\n            // @ts-ignore\n            this.removeListener = this.defaultRemoveListener;\n        }\n        if ((0, provider_utils_1.hasProperty)(this.existingProvider, 'removeAllListener')) {\n            // @ts-ignore\n            this.removeAllListener = this.defaultRemoveAllListeners;\n        }\n        if ((0, provider_utils_1.hasProperty)(this.existingProvider, 'reset')) {\n            // @ts-ignore\n            this.reset = this.defaultReset;\n        }\n    };\n    Object.defineProperty(CeloProvider.prototype, \"connected\", {\n        get: function () {\n            return this.existingProvider.connected;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CeloProvider.prototype.supportsSubscriptions = function () {\n        return this.existingProvider.supportsSubscriptions();\n    };\n    CeloProvider.prototype.defaultOn = function (type, callback) {\n        ;\n        this.existingProvider.on(type, callback);\n    };\n    CeloProvider.prototype.defaultOnce = function (type, callback) {\n        ;\n        this.existingProvider.once(type, callback);\n    };\n    CeloProvider.prototype.defaultRemoveListener = function (type, callback) {\n        ;\n        this.existingProvider.removeListener(type, callback);\n    };\n    CeloProvider.prototype.defaultRemoveAllListeners = function (type) {\n        ;\n        this.existingProvider.removeAllListeners(type);\n    };\n    CeloProvider.prototype.defaultReset = function () {\n        ;\n        this.existingProvider.reset();\n    };\n    return CeloProvider;\n}());\nexports.CeloProvider = CeloProvider;\n//# sourceMappingURL=celo-provider.js.map"]},"metadata":{},"sourceType":"script"}