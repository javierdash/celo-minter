{"ast":null,"code":"import { create as ipfsHttpClient } from \"ipfs-http-client\";\nimport axios from \"axios\"; // initialize IPFS\n\nconst client = ipfsHttpClient(\"https://ipfs.infura.io:5001/api/v0\"); // mint an NFT\n\nexport const createNft = async (minterContract, performActions, _ref) => {\n  let {\n    name,\n    description,\n    ipfsImage,\n    ownerAddress,\n    attributes\n  } = _ref;\n  await performActions(async kit => {\n    if (!name || !description || !ipfsImage) return;\n    const {\n      defaultAccount\n    } = kit; // convert NFT metadata to JSON format\n\n    const data = JSON.stringify({\n      name,\n      description,\n      image: ipfsImage,\n      owner: defaultAccount,\n      attributes\n    });\n\n    try {\n      // save NFT metadata to IPFS\n      const added = await client.add(data); // IPFS url for uploaded metadata\n\n      const url = `https://ipfs.infura.io/ipfs/${added.path}`; // mint the NFT and save the IPFS url to the blockchain\n\n      let transaction = await minterContract.methods.safeMint(ownerAddress, url).send({\n        from: defaultAccount\n      });\n      return transaction;\n    } catch (error) {\n      console.log(\"Error uploading file: \", error);\n    }\n  });\n}; // function to upload a file to IPFS\n\nexport const uploadToIpfs = async e => {\n  const file = e.target.files[0];\n  if (!file) return;\n\n  try {\n    const added = await client.add(file, {\n      progress: prog => console.log(`received: ${prog}`)\n    });\n    return `https://ipfs.infura.io/ipfs/${added.path}`;\n  } catch (error) {\n    console.log(\"Error uploading file: \", error);\n  }\n}; // fetch all NFTs on the smart contract\n\nexport const getNfts = async minterContract => {\n  try {\n    const nfts = [];\n    const nftsLength = await minterContract.methods.totalSupply().call();\n\n    for (let i = 0; i < Number(nftsLength); i++) {\n      const nft = new Promise(async resolve => {\n        const res = await minterContract.methods.tokenURI(i).call();\n        const meta = await fetchNftMeta(res);\n        const owner = await fetchNftOwner(minterContract, i);\n        resolve({\n          index: i,\n          owner,\n          name: meta.data.name,\n          image: meta.data.image,\n          description: meta.data.description,\n          attributes: meta.data.attributes\n        });\n      });\n      nfts.push(nft);\n    }\n\n    return Promise.all(nfts);\n  } catch (e) {\n    console.log({\n      e\n    });\n  }\n}; // get the metedata for an NFT from IPFS\n\nexport const fetchNftMeta = async ipfsUrl => {\n  try {\n    if (!ipfsUrl) return null;\n    const meta = await axios.get(ipfsUrl);\n    return meta;\n  } catch (e) {\n    console.log({\n      e\n    });\n  }\n}; // get the owner address of an NFT\n\nexport const fetchNftOwner = async (minterContract, index) => {\n  try {\n    return await minterContract.methods.ownerOf(index).call();\n  } catch (e) {\n    console.log({\n      e\n    });\n  }\n}; // get the address that deployed the NFT contract\n\nexport const fetchNftContractOwner = async minterContract => {\n  try {\n    let owner = await minterContract.methods.owner().call();\n    return owner;\n  } catch (e) {\n    console.log({\n      e\n    });\n  }\n};","map":{"version":3,"sources":["/Users/Lucy/PROYECTOS/celo-react-boilerplate/src/utils/minter.js"],"names":["create","ipfsHttpClient","axios","client","createNft","minterContract","performActions","name","description","ipfsImage","ownerAddress","attributes","kit","defaultAccount","data","JSON","stringify","image","owner","added","add","url","path","transaction","methods","safeMint","send","from","error","console","log","uploadToIpfs","e","file","target","files","progress","prog","getNfts","nfts","nftsLength","totalSupply","call","i","Number","nft","Promise","resolve","res","tokenURI","meta","fetchNftMeta","fetchNftOwner","index","push","all","ipfsUrl","get","ownerOf","fetchNftContractOwner"],"mappings":"AAAA,SAAQA,MAAM,IAAIC,cAAlB,QAAuC,kBAAvC;AACA,OAAOC,KAAP,MAAkB,OAAlB,C,CAEA;;AACA,MAAMC,MAAM,GAAGF,cAAc,CAAC,oCAAD,CAA7B,C,CAEA;;AACA,OAAO,MAAMG,SAAS,GAAG,OACrBC,cADqB,EAErBC,cAFqB,WAIpB;AAAA,MADD;AAACC,IAAAA,IAAD;AAAOC,IAAAA,WAAP;AAAoBC,IAAAA,SAApB;AAA+BC,IAAAA,YAA/B;AAA6CC,IAAAA;AAA7C,GACC;AACD,QAAML,cAAc,CAAC,MAAOM,GAAP,IAAe;AAChC,QAAI,CAACL,IAAD,IAAS,CAACC,WAAV,IAAyB,CAACC,SAA9B,EAAyC;AACzC,UAAM;AAACI,MAAAA;AAAD,QAAmBD,GAAzB,CAFgC,CAIhC;;AACA,UAAME,IAAI,GAAGC,IAAI,CAACC,SAAL,CAAe;AACxBT,MAAAA,IADwB;AAExBC,MAAAA,WAFwB;AAGxBS,MAAAA,KAAK,EAAER,SAHiB;AAIxBS,MAAAA,KAAK,EAAEL,cAJiB;AAKxBF,MAAAA;AALwB,KAAf,CAAb;;AAQA,QAAI;AAEA;AACA,YAAMQ,KAAK,GAAG,MAAMhB,MAAM,CAACiB,GAAP,CAAWN,IAAX,CAApB,CAHA,CAKA;;AACA,YAAMO,GAAG,GAAI,+BAA8BF,KAAK,CAACG,IAAK,EAAtD,CANA,CAQA;;AACA,UAAIC,WAAW,GAAG,MAAMlB,cAAc,CAACmB,OAAf,CACnBC,QADmB,CACVf,YADU,EACIW,GADJ,EAEnBK,IAFmB,CAEd;AAACC,QAAAA,IAAI,EAAEd;AAAP,OAFc,CAAxB;AAIA,aAAOU,WAAP;AACH,KAdD,CAcE,OAAOK,KAAP,EAAc;AACZC,MAAAA,OAAO,CAACC,GAAR,CAAY,wBAAZ,EAAsCF,KAAtC;AACH;AACJ,GA9BmB,CAApB;AA+BH,CApCM,C,CAuCP;;AACA,OAAO,MAAMG,YAAY,GAAG,MAAOC,CAAP,IAAa;AACrC,QAAMC,IAAI,GAAGD,CAAC,CAACE,MAAF,CAASC,KAAT,CAAe,CAAf,CAAb;AACA,MAAI,CAACF,IAAL,EAAW;;AACX,MAAI;AACA,UAAMd,KAAK,GAAG,MAAMhB,MAAM,CAACiB,GAAP,CAAWa,IAAX,EAAiB;AACjCG,MAAAA,QAAQ,EAAGC,IAAD,IAAUR,OAAO,CAACC,GAAR,CAAa,aAAYO,IAAK,EAA9B;AADa,KAAjB,CAApB;AAGA,WAAQ,+BAA8BlB,KAAK,CAACG,IAAK,EAAjD;AACH,GALD,CAKE,OAAOM,KAAP,EAAc;AACZC,IAAAA,OAAO,CAACC,GAAR,CAAY,wBAAZ,EAAsCF,KAAtC;AACH;AACJ,CAXM,C,CAcP;;AACA,OAAO,MAAMU,OAAO,GAAG,MAAOjC,cAAP,IAA0B;AAC7C,MAAI;AACA,UAAMkC,IAAI,GAAG,EAAb;AACA,UAAMC,UAAU,GAAG,MAAMnC,cAAc,CAACmB,OAAf,CAAuBiB,WAAvB,GAAqCC,IAArC,EAAzB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,MAAM,CAACJ,UAAD,CAA1B,EAAwCG,CAAC,EAAzC,EAA6C;AACzC,YAAME,GAAG,GAAG,IAAIC,OAAJ,CAAY,MAAOC,OAAP,IAAmB;AACvC,cAAMC,GAAG,GAAG,MAAM3C,cAAc,CAACmB,OAAf,CAAuByB,QAAvB,CAAgCN,CAAhC,EAAmCD,IAAnC,EAAlB;AACA,cAAMQ,IAAI,GAAG,MAAMC,YAAY,CAACH,GAAD,CAA/B;AACA,cAAM9B,KAAK,GAAG,MAAMkC,aAAa,CAAC/C,cAAD,EAAiBsC,CAAjB,CAAjC;AACAI,QAAAA,OAAO,CAAC;AACJM,UAAAA,KAAK,EAAEV,CADH;AAEJzB,UAAAA,KAFI;AAGJX,UAAAA,IAAI,EAAE2C,IAAI,CAACpC,IAAL,CAAUP,IAHZ;AAIJU,UAAAA,KAAK,EAAEiC,IAAI,CAACpC,IAAL,CAAUG,KAJb;AAKJT,UAAAA,WAAW,EAAE0C,IAAI,CAACpC,IAAL,CAAUN,WALnB;AAMJG,UAAAA,UAAU,EAAEuC,IAAI,CAACpC,IAAL,CAAUH;AANlB,SAAD,CAAP;AAQH,OAZW,CAAZ;AAaA4B,MAAAA,IAAI,CAACe,IAAL,CAAUT,GAAV;AACH;;AACD,WAAOC,OAAO,CAACS,GAAR,CAAYhB,IAAZ,CAAP;AACH,GApBD,CAoBE,OAAOP,CAAP,EAAU;AACRH,IAAAA,OAAO,CAACC,GAAR,CAAY;AAACE,MAAAA;AAAD,KAAZ;AACH;AACJ,CAxBM,C,CA0BP;;AACA,OAAO,MAAMmB,YAAY,GAAG,MAAOK,OAAP,IAAmB;AAC3C,MAAI;AACA,QAAI,CAACA,OAAL,EAAc,OAAO,IAAP;AACd,UAAMN,IAAI,GAAG,MAAMhD,KAAK,CAACuD,GAAN,CAAUD,OAAV,CAAnB;AACA,WAAON,IAAP;AACH,GAJD,CAIE,OAAOlB,CAAP,EAAU;AACRH,IAAAA,OAAO,CAACC,GAAR,CAAY;AAACE,MAAAA;AAAD,KAAZ;AACH;AACJ,CARM,C,CAWP;;AACA,OAAO,MAAMoB,aAAa,GAAG,OAAO/C,cAAP,EAAuBgD,KAAvB,KAAiC;AAC1D,MAAI;AACA,WAAO,MAAMhD,cAAc,CAACmB,OAAf,CAAuBkC,OAAvB,CAA+BL,KAA/B,EAAsCX,IAAtC,EAAb;AACH,GAFD,CAEE,OAAOV,CAAP,EAAU;AACRH,IAAAA,OAAO,CAACC,GAAR,CAAY;AAACE,MAAAA;AAAD,KAAZ;AACH;AACJ,CANM,C,CAQP;;AACA,OAAO,MAAM2B,qBAAqB,GAAG,MAAOtD,cAAP,IAA0B;AAC3D,MAAI;AACA,QAAIa,KAAK,GAAG,MAAMb,cAAc,CAACmB,OAAf,CAAuBN,KAAvB,GAA+BwB,IAA/B,EAAlB;AACA,WAAOxB,KAAP;AACH,GAHD,CAGE,OAAOc,CAAP,EAAU;AACRH,IAAAA,OAAO,CAACC,GAAR,CAAY;AAACE,MAAAA;AAAD,KAAZ;AACH;AACJ,CAPM","sourcesContent":["import {create as ipfsHttpClient} from \"ipfs-http-client\";\nimport axios from \"axios\";\n\n// initialize IPFS\nconst client = ipfsHttpClient(\"https://ipfs.infura.io:5001/api/v0\");\n\n// mint an NFT\nexport const createNft = async (\n    minterContract,\n    performActions,\n    {name, description, ipfsImage, ownerAddress, attributes}\n) => {\n    await performActions(async (kit) => {\n        if (!name || !description || !ipfsImage) return;\n        const {defaultAccount} = kit;\n\n        // convert NFT metadata to JSON format\n        const data = JSON.stringify({\n            name,\n            description,\n            image: ipfsImage,\n            owner: defaultAccount,\n            attributes,\n        });\n\n        try {\n\n            // save NFT metadata to IPFS\n            const added = await client.add(data);\n\n            // IPFS url for uploaded metadata\n            const url = `https://ipfs.infura.io/ipfs/${added.path}`;\n\n            // mint the NFT and save the IPFS url to the blockchain\n            let transaction = await minterContract.methods\n                .safeMint(ownerAddress, url)\n                .send({from: defaultAccount});\n\n            return transaction;\n        } catch (error) {\n            console.log(\"Error uploading file: \", error);\n        }\n    });\n};\n\n\n// function to upload a file to IPFS\nexport const uploadToIpfs = async (e) => {\n    const file = e.target.files[0];\n    if (!file) return;\n    try {\n        const added = await client.add(file, {\n            progress: (prog) => console.log(`received: ${prog}`),\n        });\n        return `https://ipfs.infura.io/ipfs/${added.path}`;\n    } catch (error) {\n        console.log(\"Error uploading file: \", error);\n    }\n};\n\n\n// fetch all NFTs on the smart contract\nexport const getNfts = async (minterContract) => {\n    try {\n        const nfts = [];\n        const nftsLength = await minterContract.methods.totalSupply().call();\n        for (let i = 0; i < Number(nftsLength); i++) {\n            const nft = new Promise(async (resolve) => {\n                const res = await minterContract.methods.tokenURI(i).call();\n                const meta = await fetchNftMeta(res);\n                const owner = await fetchNftOwner(minterContract, i);\n                resolve({\n                    index: i,\n                    owner,\n                    name: meta.data.name,\n                    image: meta.data.image,\n                    description: meta.data.description,\n                    attributes: meta.data.attributes,\n                });\n            });\n            nfts.push(nft);\n        }\n        return Promise.all(nfts);\n    } catch (e) {\n        console.log({e});\n    }\n};\n\n// get the metedata for an NFT from IPFS\nexport const fetchNftMeta = async (ipfsUrl) => {\n    try {\n        if (!ipfsUrl) return null;\n        const meta = await axios.get(ipfsUrl);\n        return meta;\n    } catch (e) {\n        console.log({e});\n    }\n};\n\n\n// get the owner address of an NFT\nexport const fetchNftOwner = async (minterContract, index) => {\n    try {\n        return await minterContract.methods.ownerOf(index).call();\n    } catch (e) {\n        console.log({e});\n    }\n};\n\n// get the address that deployed the NFT contract\nexport const fetchNftContractOwner = async (minterContract) => {\n    try {\n        let owner = await minterContract.methods.owner().call();\n        return owner;\n    } catch (e) {\n        console.log({e});\n    }\n};"]},"metadata":{},"sourceType":"module"}