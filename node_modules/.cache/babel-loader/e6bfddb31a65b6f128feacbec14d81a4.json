{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createAccountClaim = exports.AccountClaimType = exports.AccountClaimTypeH = void 0;\n\nvar address_1 = require(\"@celo/utils/lib/address\");\n\nvar io_1 = require(\"@celo/utils/lib/io\");\n\nvar Either_1 = require(\"fp-ts/lib/Either\");\n\nvar t = __importStar(require(\"io-ts\"));\n\nvar types_1 = require(\"./types\"); // Provide the type minus the validation that the public key and address are derived from the same private key\n\n\nexports.AccountClaimTypeH = t.type({\n  type: t.literal(types_1.ClaimTypes.ACCOUNT),\n  timestamp: types_1.TimestampType,\n  address: io_1.AddressType,\n  // io-ts way of defining optional key-value pair\n  publicKey: t.union([t.undefined, io_1.PublicKeyType])\n});\nexports.AccountClaimType = new t.Type('AccountClaimType', exports.AccountClaimTypeH.is, function (unknownValue, context) {\n  return Either_1.either.chain(exports.AccountClaimTypeH.validate(unknownValue, context), function (claim) {\n    if (claim.publicKey === undefined) {\n      return t.success(claim);\n    }\n\n    var derivedAddress = (0, address_1.publicKeyToAddress)(claim.publicKey);\n    return derivedAddress === claim.address ? t.success(claim) : t.failure(claim, context, 'public key did not match the address in the claim');\n  });\n}, function (x) {\n  return x;\n});\n\nvar createAccountClaim = function (address, publicKey) {\n  var claim = {\n    timestamp: (0, types_1.now)(),\n    type: types_1.ClaimTypes.ACCOUNT,\n    address: address,\n    publicKey: publicKey\n  };\n  var parsedClaim = exports.AccountClaimType.decode(claim);\n\n  if ((0, Either_1.isLeft)(parsedClaim)) {\n    throw new Error(\"A valid claim could not be created\");\n  }\n\n  return parsedClaim.right;\n};\n\nexports.createAccountClaim = createAccountClaim;","map":{"version":3,"sources":["../../../src/identity/claims/account.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;;AACA,IAAA,IAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,IAAA,CAAA,GAAA,YAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA,C,CAEA;;;AACa,OAAA,CAAA,iBAAA,GAAoB,CAAC,CAAC,IAAF,CAAO;AACtC,EAAA,IAAI,EAAE,CAAC,CAAC,OAAF,CAAU,OAAA,CAAA,UAAA,CAAW,OAArB,CADgC;AAEtC,EAAA,SAAS,EAAE,OAAA,CAAA,aAF2B;AAGtC,EAAA,OAAO,EAAE,IAAA,CAAA,WAH6B;AAItC;AACA,EAAA,SAAS,EAAE,CAAC,CAAC,KAAF,CAAQ,CAAC,CAAC,CAAC,SAAH,EAAc,IAAA,CAAA,aAAd,CAAR;AAL2B,CAAP,CAApB;AAQA,OAAA,CAAA,gBAAA,GAAmB,IAAI,CAAC,CAAC,IAAN,CAC9B,kBAD8B,EAE9B,OAAA,CAAA,iBAAA,CAAkB,EAFY,EAG9B,UAAC,YAAD,EAAe,OAAf,EAAsB;AACpB,SAAA,QAAA,CAAA,MAAA,CAAO,KAAP,CAAa,OAAA,CAAA,iBAAA,CAAkB,QAAlB,CAA2B,YAA3B,EAAyC,OAAzC,CAAb,EAAgE,UAAC,KAAD,EAAM;AACpE,QAAI,KAAK,CAAC,SAAN,KAAoB,SAAxB,EAAmC;AACjC,aAAO,CAAC,CAAC,OAAF,CAAU,KAAV,CAAP;AACD;;AACD,QAAM,cAAc,GAAG,CAAA,GAAA,SAAA,CAAA,kBAAA,EAAmB,KAAK,CAAC,SAAzB,CAAvB;AACA,WAAO,cAAc,KAAK,KAAK,CAAC,OAAzB,GACH,CAAC,CAAC,OAAF,CAAU,KAAV,CADG,GAEH,CAAC,CAAC,OAAF,CAAU,KAAV,EAAiB,OAAjB,EAA0B,mDAA1B,CAFJ;AAGD,GARD,CAAA;AAQE,CAZ0B,EAa9B,UAAC,CAAD,EAAE;AAAK,SAAA,CAAA;AAAC,CAbsB,CAAnB;;AAkBN,IAAM,kBAAkB,GAAG,UAAC,OAAD,EAAkB,SAAlB,EAAoC;AACpE,MAAM,KAAK,GAAG;AACZ,IAAA,SAAS,EAAE,CAAA,GAAA,OAAA,CAAA,GAAA,GADC;AAEZ,IAAA,IAAI,EAAE,OAAA,CAAA,UAAA,CAAW,OAFL;AAGZ,IAAA,OAAO,EAAA,OAHK;AAIZ,IAAA,SAAS,EAAA;AAJG,GAAd;AAOA,MAAM,WAAW,GAAG,OAAA,CAAA,gBAAA,CAAiB,MAAjB,CAAwB,KAAxB,CAApB;;AAEA,MAAI,CAAA,GAAA,QAAA,CAAA,MAAA,EAAO,WAAP,CAAJ,EAAyB;AACvB,UAAM,IAAI,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,SAAO,WAAW,CAAC,KAAnB;AACD,CAfM;;AAAM,OAAA,CAAA,kBAAA,GAAkB,kBAAlB","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createAccountClaim = exports.AccountClaimType = exports.AccountClaimTypeH = void 0;\nvar address_1 = require(\"@celo/utils/lib/address\");\nvar io_1 = require(\"@celo/utils/lib/io\");\nvar Either_1 = require(\"fp-ts/lib/Either\");\nvar t = __importStar(require(\"io-ts\"));\nvar types_1 = require(\"./types\");\n// Provide the type minus the validation that the public key and address are derived from the same private key\nexports.AccountClaimTypeH = t.type({\n    type: t.literal(types_1.ClaimTypes.ACCOUNT),\n    timestamp: types_1.TimestampType,\n    address: io_1.AddressType,\n    // io-ts way of defining optional key-value pair\n    publicKey: t.union([t.undefined, io_1.PublicKeyType]),\n});\nexports.AccountClaimType = new t.Type('AccountClaimType', exports.AccountClaimTypeH.is, function (unknownValue, context) {\n    return Either_1.either.chain(exports.AccountClaimTypeH.validate(unknownValue, context), function (claim) {\n        if (claim.publicKey === undefined) {\n            return t.success(claim);\n        }\n        var derivedAddress = (0, address_1.publicKeyToAddress)(claim.publicKey);\n        return derivedAddress === claim.address\n            ? t.success(claim)\n            : t.failure(claim, context, 'public key did not match the address in the claim');\n    });\n}, function (x) { return x; });\nvar createAccountClaim = function (address, publicKey) {\n    var claim = {\n        timestamp: (0, types_1.now)(),\n        type: types_1.ClaimTypes.ACCOUNT,\n        address: address,\n        publicKey: publicKey,\n    };\n    var parsedClaim = exports.AccountClaimType.decode(claim);\n    if ((0, Either_1.isLeft)(parsedClaim)) {\n        throw new Error(\"A valid claim could not be created\");\n    }\n    return parsedClaim.right;\n};\nexports.createAccountClaim = createAccountClaim;\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"script"}